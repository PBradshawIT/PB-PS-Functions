Function Add-ChromeShortcut{
	#Requires -RunAsAdministrator

	param
	(
		[Parameter(Mandatory=$true)]
		[string]$Label,

		[Parameter(Mandatory=$true)]
		[string]$Url
	)

	If (Test-Path -Path 'C:\Program Files\Google\Chrome\Application\chrome.exe') {
		$TargetFile = "C:\Program Files\Google\Chrome\Application\chrome.exe"
	} ElseIf (Test-Path -Path 'C:\Program Files (x86)\Google\Chrome\Application\chrome.exe') {
		$TargetFile = "C:\Program Files (x86)\Google\Chrome\Application\chrome.exe"
	} Else {
		Write-Host "Google Chrome was not found. Please install manually or with Chocolatey:"
		Write-Host "   Install-Choco"
		Write-Host "   choco install GoogleChrome"
	}

	If ($TargetFile) {
		$ShortcutFile = "$env:Public\Desktop\" + $Label + ".lnk"
		$WScriptShell = New-Object -ComObject WScript.Shell
		$Shortcut = $WScriptShell.CreateShortcut($ShortcutFile)
		$Shortcut.TargetPath = $TargetFile
		$Shortcut.Arguments = $Url
		$Shortcut.Save()
	}

}

Function Add-FileFolderShortcut {

	param
	(
		[Parameter(Mandatory=$true)]
		[string]$SourceLnk,

		[Parameter(Mandatory=$true)]
		[string]$DestinationPath
	)

	$WshShell = New-Object -comObject WScript.Shell
	$Shortcut = $WshShell.CreateShortcut($SourceLnk)
	$Shortcut.TargetPath = $DestinationPath
	$Shortcut.Save()

}

Function Add-IEShortcut {
	param
	(
		[Parameter(Mandatory=$true)]
		[string]$Label,

		[Parameter(Mandatory=$true)]
		[string]$Url
	)

	$TargetFile = "C:\Program Files\Internet Explorer\iexplore.exe"
	$ShortcutFile = "$env:Public\Desktop\" + $Label + ".lnk"
	$WScriptShell = New-Object -ComObject WScript.Shell
	$Shortcut = $WScriptShell.CreateShortcut($ShortcutFile)
	$Shortcut.TargetPath = $TargetFile
	$Shortcut.Arguments = $Url
	$Shortcut.Save()

}

Function Add-WebShortcut{
	param
	(
		[string]$Label,
		[string]$Url
	)

	Write-Host "Adding a shortcut to $Label to the desktop"
	$Shell = New-Object -ComObject ("WScript.Shell")
	$URLFilePath = $env:Public + "\Desktop\" + $Label + ".url"
	$Favorite = $Shell.CreateShortcut($URLFilePath)
	$Favorite.TargetPath = $Url
	$Favorite.Save()
}

Function Backup-LastUser {
	$RegKey = "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Authentication\LogonUI"
	$RegFile = "C:\PB\LastLoggedOnUser.reg"
	Write-Host "Backuping up last logged on user"
	reg export $RegKey $RegFile /y
	Write-Host "Trimming export"
	(Get-Content $RegFile)[0..10] | Out-File -FilePath $RegFile -Force
	$User = (Select-String -Path $RegFile -Pattern '"LastLoggedOnUser"' -SimpleMatch).Line
	Write-Host "$User has been backed up to $RegFile"
	Write-Host "`nTry the command Restore-LastUser"
}

Function Connect-O365Exchange {
		If (-not (Get-Command Connect-ExchangeOnline -ErrorAction SilentlyContinue)) {
			Write-Host "Installing the Exchange Online Management module"
			Set-PSRepository -Name PSGallery -InstallationPolicy Trusted
			Install-Module -Name ExchangeOnlineManagement -AllowClobber -Force
			$ModVer = (Get-Command Connect-ExchangeOnline).Version
			If ($ModVer) {
				Write-Host "Exchange Online Management module version $ModVer has been installed."
			} Else {
				Write-Host "Exchange Online Management module failed to install."
				Break
			}
		} Else {
			$Readhost = 'N'
			$Readhost = Read-Host "Do you want to check for module updates? This should be done periodically. `n(y/N)"
			Switch ($ReadHost)
			{
				Y {
					$ModVer = (Get-Command Connect-ExchangeOnline).Version
					$AvailableModVer = (Find-Module ExchangeOnlineManagement -Repository PSGallery).Version
					If ($ModVer -ne $AvailableModVer) {
						Write-host "ExchangeOnlineManagement has an update from $ModVer to $AvailableModVer.`nInstalling the update."
						Set-PSRepository -Name PSGallery -InstallationPolicy Trusted
						Install-Module -Name ExchangeOnlineManagement -AllowClobber -Force
					} Else {
						Write-host "ExchangeOnlineManagement is already up to date at version $AvailableModVer."
					}
				}
				N { Write-Host "Skipping update check." }
				Default { Write-Host "Skipping update check." }
			}
		}

	If ($PSVersionTable.PSEdition -like "Desktop") {
		Connect-ExchangeOnline -ShowBanner:$false

	} Else {
		Write-Host -ForegroundColor Green -BackgroundColor DarkRed "Warning! You are using a CORE edition of Powershell. You will need to authenticate via a browser window."
		Connect-ExchangeOnline -ShowBanner:$false -Device
	}

	Write-Host -ForegroundColor White -BackgroundColor DarkRed @"
		Be sure to disconnect the remote PowerShell session when you're finished.
		If you close the Windows PowerShell window without disconnecting the session,
		you could use up all the remote PowerShell sessions available to you,
		and you'll need to wait for the sessions to expire.
		To disconnect the remote PowerShell session, run the following command.

		Disconnect-O365Exchange
"@

<#
	.SYNOPSIS
		Initiates an Office 365 Exchange connection that is compatible with MFA.
		This is not compatible with Powershell Core.

	.LINK
		https://docs.microsoft.com/en-us/powershell/exchange/connect-to-exchange-online-powershell?view=exchange-ps

	.EXAMPLE
		Connect-O365Exchange
		Yup, that's it!
#>
}

Function Connect-Wifi {
	param
		(
			[Parameter(Mandatory=$False)]
			[string]$NetworkSSID,

			[Parameter(Mandatory=$true)]
			[string]$NetworkPassword,

			[ValidateSet('WEP','WPA','WPA2','WPA2PSK')]
			[Parameter(Mandatory=$False)]
			[string]$Authentication = 'WPA2PSK',

			[ValidateSet('AES','TKIP')]
			[Parameter(Mandatory=$False)]
			[string]$Encryption = 'AES'
		)

	# Create the WiFi profile, set the profile to auto connect
	$WirelessProfile = @'
<WLANProfile xmlns="http://www.microsoft.com/networking/WLAN/profile/v1">
	<name>{0}</name>
	<SSIDConfig>
		<SSID>
			<name>{0}</name>
		</SSID>
	</SSIDConfig>
	<connectionType>ESS</connectionType>
	<connectionMode>auto</connectionMode>
	<MSM>
		<security>
			<authEncryption>
				<authentication>{2}</authentication>
				<encryption>{3}</encryption>
				<useOneX>false</useOneX>
			</authEncryption>
			<sharedKey>
				<keyType>passPhrase</keyType>
				<protected>false</protected>
				<keyMaterial>{1}</keyMaterial>
			</sharedKey>
		</security>
	</MSM>
</WLANProfile>
'@ -f $NetworkSSID, $NetworkPassword, $Authentication, $Encryption

	# Create the XML file locally
	$random = Get-Random -Minimum 1111 -Maximum 99999999
	$tempProfileXML = "$env:TEMP\tempProfile$random.xml"
	$WirelessProfile | Out-File $tempProfileXML

	# Add the WiFi profile and connect
	Start-Process netsh ('wlan add profile filename={0}' -f $tempProfileXML)

	# Connect to the WiFi network - only if you need to
	$WifiNetworks = (netsh wlan show network)
	$NetworkSSIDSearch = '*' + $NetworkSSID + '*'
	If ($WifiNetworks -like $NetworkSSIDSearch) {
		Try {
			Write-Host "Found SSID: $NetworkSSID `nAttempting to connect"
			Start-Process netsh ('wlan connect name="{0}"' -f $NetworkSSID)
			Start-Sleep 5
			netsh interface show interface
		}
		Catch {
			Remove-Item -Force $tempProfileXML
		}
	} Else {
		Write-Host "Did not find SSID: $NetworkSSID `nConnection profile stored for later use."
	}
	Remove-Item -Force $tempProfileXML
}

Function Debug-UmbrellaDNS {
	$X64exe = ${Env:ProgramFiles(x86)} + "\OpenDNS\Umbrella Roaming Client\UmbrellaDiagnostic.exe"
	$X86exe = $ENV:ProgramFiles + "\OpenDNS\Umbrella Roaming Client\UmbrellaDiagnostic.exe"
	If (Test-Path $X64exe -ea SilentlyContinue) {
		$UDexe = $X64exe
	} ElseIf (Test-Path $X86exe -ea SilentlyContinue) {
		$UDexe = $X86exe
	} Else {
		Write-Host "Umbrella Diagnostics do not appear to be installed."
		Break
	}
	Write-Host "Here is the help file for UmbrellaDiagnostic.exe:"
Write-Host @"

  -d, --domain=VALUE         A specific URL to target with tests (e.g.
                               opendns.com)
  -s, --silent               Automatically run tests in silent mode (will not
                               show the UI or new windows; defaults to -i
                               output)
  -i, --internet             Output all results to diagnostic.opendns.com;
                               destination URL will print to console as
                               'url=URL'
  -o, --output=VALUE         Output to a file, which will print to console as
                               'outputFile=FILE'; can be a full path, make sure
                               to use "quotes" if needed
  -c, --console              Output all results to console as text
      --erc                  Force the Roaming Client tests to be performed
      --noerc                Skip the Roaming Client tests even if it's
                               installed
  -h, -?, --help             Display this usage statement

If run without -o or -c arguments, -i is the default output; if run with -o or -c, then -i must be explicitly set if desired as additional output.

"@
	Write-Host "Recommend running with arguments '--silent --internet --console'.`nAdd --domain=<domain> to test internal or external targets.`n"
	$Args = Read-Host "What arguments would you like to add? Just press enter if you wish to launch the window.`n"
	If ($Args) {
		Start-Process $UDexe -ArgumentList $Args
	} Else {
		Start-Process $UDexe
	}
}

Function Disconnect-O365Exchange {
	Disconnect-ExchangeOnline -Confirm:$false
}

Function Disable-ITSupportLocalExpiration {
	Write-Host "Set local ITSupport account to never expire"
		Set-LocalUser -Name "ITSupport" -PasswordNeverExpires $True
}

Function Convert-ToSharedMailbox {
	param
		(
			[Parameter(Mandatory=$false)]
			[string]$DateLeft,

			[Parameter(Mandatory=$false)]
			[string]$Alias,
			
			[Parameter(Mandatory=$false)]
			[string]$GiveAccessTo,
			
			[Parameter(Mandatory=$false)]
			[ValidateSet('FullAccess','ReadPermission')]
			[string]$GiveAccessPermission,
			
			[Parameter(Mandatory=$false)]
			[string]$DirectEmailTo,
			
			[Parameter(Mandatory=$false)]
			[switch]$NoAccess = $False,
			
			[Parameter(Mandatory=$false)]
			[switch]$NoReply = $False
		)
		
	If (-not $DateLeft) {$DateLeft = Read-Host "Please enter the date this person left in DDMMMYYY format, i.e. 01JAN2001"}
	If (-not $Alias) {$Alias = Read-Host "Please enter the persons alias, the part of their email before the @ sign."}
	$DeletedMailbox = Get-EXOMailbox -SoftDeletedMailbox -Identity $Alias -ErrorAction SilentlyContinue
	If (-not $DeletedMailbox) {
		Do {
			#Active User Check
			If ($(Get-EXOMailbox -Identity $Alias -ErrorAction SilentlyContinue)) {
				Write-Host "That mailbox appears to be for an active user.`nPlease delete the user before proceeding..."
				Break
			}
			#Retry the alias
			$Alias = Read-Host "That alias didn't work. Enter another one or type QUIT to stop:`n"
			If ($Alias -match "QUIT") {Break}
			$DeletedMailbox = Get-EXOMailbox -SoftDeletedMailbox -Identity $Alias -ErrorAction SilentlyContinue
		} While (-not $DeletedMailbox)
	}
	
	If ($DeletedMailbox) {
		Write-Host "Deleted mailbox found."
		$Name = $DeletedMailbox.DisplayName
		$SmtpAddress = $DeletedMailbox.PrimarySmtpAddress
		Write-Host "Creating Shared Mailbox."
		New-Mailbox -Name "SHARED $Name LEFT $DateLeft" -Alias $Alias -PrimarySmtpAddress $SmtpAddress -Shared
		Write-Host "Waiting 30 seconds for mailbox to fully initialize."
		Start-Sleep -Seconds 30
		$NewSharedMailbox = Get-EXOMailbox -Identity $Alias
		$NewSharedMailbox | Select-Object DisplayName, RecipientTypeDetails
		Write-Host "Restoring deleted mailbox to new shared mailbox."
		New-MailboxRestoreRequest -SourceMailbox $DeletedMailbox.GUID.GUID -TargetMailbox $NewSharedMailbox.GUID.GUID -AllowLegacyDNMismatch
		Get-MailboxRestoreRequest | Format-Table
		Write-Host -ForegroundColor Yellow -BackgroundColor Black "Run Get-MailboxRestoreRequest to see the progress of the restore."

		#Mailbox Permissions
		If(-not $NoAccess) {
			Do {
				If ($GiveAccessPermission) {
					$Permission = $GiveAccessPermission
				} Else {
					$Response = Read-Host -Prompt "Do you want to add any permissions to the shared mailbox? (Y/n)"
					If (-not $Response) {$Response = "y"}
					If ($Response -like 'y*') {
					$Rights = "FullAccess","ReadPermission","QUIT"
					$Rights | Select-Object @{N='Index'; E={$Rights.IndexOf($_)}}, @{N='Permission'; E={$_}} | Out-Host -Paging -ErrorAction SilentlyContinue
					$Permission = Read-Host "Please enter the number of the permission you wish to assign."
					$Permission = $Rights[$Permission]
					}
				}
				If ($Permission -ne "QUIT") {
					If ($GiveAccessTo) {
						$AddUser = $GiveAccessTo
					} Else {
						$AddUser = Read-Host "Alias of the user to grant access"
					}
					If (-not $(Get-EXOMailbox -Identity $AddUser)) {
						Do {
							$AddUser = Read-Host "That alias didn't work. Enter another one or type QUIT to stop:`n"
							If ($AddUser -match "QUIT") {Break}
						} While (-not $(Get-EXOMailbox -Identity $AddUser))
					}
					Write-Host "Giving $AddUser $Permission to the mailbox."
					$NewSharedMailbox | Add-MailboxPermission -User $AddUser -AccessRights $Permission -InheritanceType All -Verbose
					$NewSharedMailbox | Get-MailboxPermission | Format-Table
				} Else { Break }
			} While ($Response -notlike 'n*')
		}

		#AutoReply
		If(-not $NoAccess) {
			If ($DirectEmailTo) {
				$ReplyTo = $DirectEmailTo
			} Else {
				$Response = Read-Host -Prompt "Do you want to an auto reply? (Y/n)"
				If (-not $Response) {$Response = "y"}
				If ($Response -like 'y*') {
					$ReplyTo = Read-Host "Alias of the user to direct emails to"
					If (-not $(Get-EXOMailbox -Identity $ReplyTo)) {
						Do {
							$ReplyTo = Read-Host "That alias didn't work. Enter another one or type QUIT to stop:`n"
							If ($ReplyTo -match "QUIT") {Break}
						} While (-not $(Get-EXOMailbox -Identity $ReplyTo))
					}

				}
			}
			$ReplyTo = Get-EXOMailbox -Identity $ReplyTo
			$ReplyToName = $ReplyTo.DisplayName
			$ReplyToEmail = $ReplyTo.PrimarySmtpAddress
			$NewSharedMailbox | Set-MailboxAutoReplyConfiguration –InternalMessage "$Name is no longer with the organization. Please direct communications to $ReplyToName at $ReplyToEmail" –ExternalMessage "$Name is no longer with the organization. Please direct communications to $ReplyToName at $ReplyToEmail" -Verbose
			$NewSharedMailbox | Set-MailboxAutoReplyConfiguration -AutoReplyState enabled
			$NewSharedMailbox | Get-MailboxAutoReplyConfiguration | Select-Object Identity, AutoReplyState, ExternalMessage | Format-List
		}
	}
<#
	.SYNOPSIS
		Takes a deleted user, and converts their email to a shared mailbox. Can add permissions and an autoreply.
	.PARAMETER Alias
		Please enter the persons alias, the part of their email before the @ sign.
	.PARAMETER DateLeft
		Please enter the date this person left in DDMMMYYY format, i.e. 01JAN2001
	.PARAMETER GiveAccessTo
		Please enter the alias of the person who needs access to the shared mailbox. Leave blank to be prompted for multiple names.
	.PARAMETER GiveAccessPermission
		Please enter the permission level to give. Acceptible values are 'FullAccess' and 'ReadPermission'.
	.PARAMETER DirectEmailTo
		Please enter the alias of the person who people should be directed to in the auto reply.
	.PARAMETER NoAccess
		Add this switch if you do not want to be prompted for giving access.
	.PARAMETER NoReply
		Add this switch if you do not want to be prompted for setting up an autoreply.
	.EXAMPLE
		Convert-ToSharedMailbox -DateLeft "30SEP2021" -Alias cscippio
	#>
}

Function Disable-DailyReboot {
<#
	.SYNOPSIS
		Permanently deletes the scheduled task named "Daily Restart"
#>
	$DailyRebootTask = Get-ScheduledTask -TaskName "Daily Restart" -ErrorAction SilentlyContinue
	If ($DailyRebootTask) {
		$DailyRebootTask | Unregister-ScheduledTask -Confirm:$false
	}
	If (!(Get-ScheduledTask -TaskName "Daily Restart" -ErrorAction SilentlyContinue)) {
		Write-Host "The task 'Daily Restart' has been successfully removed."
	} Else {
		Write-Host "The task 'Daily Restart' has NOT been successfully removed. Please investigate!"
	}
}

Function Disable-FastStartup {
	Write-Host "Disable Windows Fast Startup"
		REG ADD "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Power" /v HiberbootEnabled /t REG_DWORD /d "0" /f
		powercfg -h off
}

Function Disable-Sleep {
<#
.Synopsis
   Function to suspend your current Power Plan settings when running a PowerShell script.
.SYNOPSIS
   Function to suspend your current Power Plan settings when running a PowerShell script.
   Scenario: When downloading files using Robocopy from PowerShell you don't want your
   laptop to go into sleep mode.
.EXAMPLE
   Disable-Sleep
   Run mylongrunningscript with Display idle timeout prevented and verbose messages
#>

	If (!(Test-Path "C:\ProgramData\chocolatey\lib\dontsleep.portable\tools\DontSleep_x64_p.exe")) {
		If (!(Get-Command choco -ErrorAction SilentlyContinue)) {Install-Choco}
		choco install dontsleep.portable -y
	}
	& C:\ProgramData\chocolatey\lib\dontsleep.portable\tools\DontSleep_x64_p.exe -bg please_sleep_mode=0 enable=1
}

Function Disconnect-AllUsers {
<#
	.SYNOPSIS
		Logs off all users from a machine.
#>
	(quser) -replace ">"," " -replace "\s+","," -replace "IDLE,TIME","IDLE TIME" -replace "LOGON,TIME","LOGON TIME" | ConvertFrom-Csv -Delimiter "," | ForEach-Object {
		logoff ($_.ID)
	}
}

Function Disconnect-NetExtender {

	If (([string]::IsNullOrWhiteSpace($DC)) -or (-not (Test-Connection -comp $DC -quiet))) {
		If (!(Test-Path -LiteralPath 'C:\Program Files (x86)\SonicWALL\SSL-VPN\NetExtender\NEClI.exe')) {
			Write-Host "This command only works if you have Sonicwall NetExtender installed."
		}
		Write-host "Initiating VPN disconnection"
		& 'C:\Program Files (x86)\SonicWALL\SSL-VPN\NetExtender\NEClI.exe' disconnect
		& 'C:\Program Files (x86)\SonicWALL\SSL-VPN\NetExtender\NEClI.exe' disconnect
	}
<#
	.SYNOPSIS
		Disconnects an existing SSLVPN connection to a site using Sonicwall NetExtender
	.EXAMPLE
		Disconnect-NetExtender
		This example disconnects from the VPN session.
#>
}

Function Enable-O365AuditLog {
<#
	.SYNOPSIS
		Sets auditig on all mailboxes in the organization as well as sets the default setting.

	.LINK
		https://docs.microsoft.com/en-us/microsoft-365/compliance/enable-mailbox-auditing

	.LINK
		https://support.microsoft.com/en-us/help/4026501/office-auditing-in-office-365-for-admins
#>
	If (Get-Command Get-Mailbox -ErrorAction SilentlyContinue){
		Write-Host "Enabling Auditing for all existing mailboxes"
		Get-Mailbox -ResultSize Unlimited -Filter {RecipientTypeDetails -eq "UserMailbox"} | Set-Mailbox -AuditEnabled $true -Verbose
		Write-Host "Enabling Auditing for the organization as a whole"
		Set-OrganizationConfig -AuditDisabled $False
		Write-Host "Checking the orginazation config. If auditing is enabled, this setting should show as 'False'"
		Get-OrganizationConfig | Format-List AuditDisabled
	} Else {
		Write-Host "You are not connected to an exchange server. Try the command 'Connect-O365Exchange'"
	}
}

Function Enable-Sleep {
	If (Get-Process -Name "DontSleep_x64_p") {
		Write-Host "Resuming power management plan"
		Stop-Process -Name "DontSleep_x64_p" -Force
	} Else {
		Write-Host "Disable-Sleep wasn't running. Did you run 'Disable-Sleep'?"
	}
}

Function Enable-SSL {
	Write-Host "Enabling SSL"
	try {
	# Set TLS 1.2 (3072), then TLS 1.1 (768), then TLS 1.0 (192)
	# Use integers because the enumeration values for TLS 1.2 and TLS 1.1 won't
	# exist in .NET 4.0, even though they are addressable if .NET 4.5+ is
	# installed (.NET 4.5 is an in-place upgrade).
	[System.Net.ServicePointManager]::SecurityProtocol = 3072 -bor 768 -bor 192
	} catch {
	Write-Output 'Unable to set PowerShell to use TLS 1.2 and TLS 1.1 due to old .NET Framework installed. If you see underlying connection closed or trust errors, you may need to upgrade to .NET Framework 4.5+ and PowerShell v3+.'
	}
}

Function Expand-Terminal {
	mode con: cols=120 lines=60
	$host.UI.RawUI.BufferSize = New-Object System.Management.Automation.Host.Size(120,10240)
}

Function Export-LDAPSCertificate {
	<#
	.SYNOPSIS
		If the server responds to requests on the LDAPS port 636, the function will attempt to isolate the Certificate in use and export it to C:\PB\LDAPScerExport.cer
	#>
	If (Test-NetConnection -ComputerName localhost -Port 636 -InformationLevel Quiet) {
		$Cert = (Get-ChildItem -Path Cert:\LocalMachine -Recurse | Where-Object {$_.NotAfter -Gt (Get-Date) -and $_.Subject -like "*$env:computername.$env:userdnsdomain*" -and $_.NotAfter -eq ($_.NotBefore).AddYears(1)})
		$Cert | Select-Object Subject, NotBefore, NotAfter | Format-List
		$Path = "C:\PB\LDAPScerExport.cer"
		Write-Host "Exporting current likely LDAPS Certificate to $Path"
		$Cert | Export-Certificate -Type cer -FilePath C:\PB\LDAPScerExport.cer -Force | Out-Null
	} Else {
		Write-Warning "This computer does not appear to be serving LDAPS requests."
		Break
	}
}

Function Get-PBPS {
	If (Get-Module -Name PBPS -ErrorAction SilentlyContinue){
		# List imported functions from PBPS
		Write-Host ====================================================
		Write-Host "The below functions are now loaded and ready to use:"
		Write-Host ====================================================
			Get-Command -Module PBPS | Format-Wide -Column 3
		Write-Host ====================================================
		Write-Host "Type: 'Help <function name> -Detailed' for more info"
		Write-Host ====================================================
	} Else {
	$progressPreference = 'silentlyContinue'
	Invoke-WebRequest https://raw.githubusercontent.com/PBradshawIT/PB-PS-Functions/main/PB-PS-Functions.txt -UseBasicParsing | Invoke-Expression
	# List imported functions from PBPS
		Write-Host ====================================================
		Write-Host "The below functions are now loaded and ready to use:"
		Write-Host ====================================================
			Get-Command -Module PBPS | Format-Wide -Column 3
		Write-Host ====================================================
		Write-Host "Type: 'Help <function name> -Detailed' for more info"
		Write-Host ====================================================
	}
}

Function Get-BitLockerKey {
	param
		(
			[Parameter(Mandatory=$false)]
			[string]$Computer
		)
	#$Computer = "OPTIPLEX7040-20"
	$Computers = Get-ADComputer -Filter 'ObjectClass -eq "computer"'
	$AllComputers = @()
	#$strToReport = new-object psobject
	$Computers | Foreach-object {
		#$Computer = $_.name
		#Check if the Computer Object exists
		$Computer_Object = Get-ADComputer -Filter {cn -eq $_.name} -Property msTPM-OwnerInformation, msTPM-TpmInformationForComputer
		If ($Computer_Object -eq $null){
			Write-Host "Error..."
		}
		#Check if the computer object has had a BitLocker Recovery Password
		$Bitlocker_Object = Get-ADObject -Filter {objectclass -eq 'msFVE-RecoveryInformation'} -SearchBase $Computer_Object.DistinguishedName -Properties 'msFVE-RecoveryPassword' | Select-Object -Last 1
		If ($Bitlocker_Object.'msFVE-RecoveryPassword'){
			$BitLocker_Key = $BitLocker_Object.'msFVE-RecoveryPassword'

			#$strToReport = $_.name,$BitLocker_Key
			$strToReport = [PSCustomObject]@{
				Computer = $_.name
				BitLockerKey = $BitLocker_Key
			}
			$AllComputers += $strToReport
			#Display Output
			#Write-Host $strToReport

			#Save to Report
			#$strToReport | Out-File C:\temp\Report.txt -append
		} Else {
			$BitLocker_Key = "None"
			#$strToReport = $_.name,$BitLocker_Key
			$strToReport = [PSCustomObject]@{
				Computer = $_.name
				BitLockerKey = $BitLocker_Key
			}
			$AllComputers += $strToReport
			#Write-Host $strToReport
		}
	}
	If ($Computer) {
		If ($AllComputers.Computer -NotContains $Computer) {
			Write-Host "The computer specified was not found."
		} Else {
			$ComputerInfo = new-object psobject
			$ComputerInfo = $AllComputers | Where-Object -Property Computer -eq -Value $Computer
			$ComputerInfo | Format-List
			If ($ComputerInfo.BitlockerKey -eq "None") {
				Write-Host "There is no bitlocker key for this compuer."
			} Else {

				Write-Host "The bitlocker key has been copied to the clipboard.`n"
				$ComputerInfo.BitlockerKey | Clip
			}
		}
	} Else {
		$AllComputers
	}

<#
	.SYNOPSIS
		Takes a deleted user, and converts their email to a shared mailbox. Can add permissions and an autoreply.
	.PARAMETER Computer
		[Optional] Specify the name of the computer to retrieve the BitLockerKey for. Will copy the key to the clipboard if specified.
	.EXAMPLE
		Get-BitLockerKey -Computer "ACG-Desktop23"
	#>
}

Function Get-DiskUsage($path=".") {
    Write-Host -ForegroundColor Cyan "  (large folders may take long to calculate...)"
    Get-ChildItem $path | ForEach-Object {
        $file = $_
        Get-ChildItem -r $_.FullName |
        Measure-Object -property length -sum -ErrorAction SilentlyContinue |
        Select-Object @{Name="Name";Expression={$file}},
        @{Name="Space Used (MB)";Expression={([math]::Round(($_.Sum/1024/1024),2))}}
    } | Format-Table -AutoSize
	<#
	.SYNOPSIS
		Either in the current directory or the given path, find all child items
		and calculate their cumulative size. Output the name of the folder
		and the space used in Megabytes. If this function is loaded by normal
		means for this repository, it will be available by its assigned alias 'du'.
	.PARAMETER Path
		[Optional] Path to the folder to calculate size of child items.
	.EXAMPLE
		Get-DiskUsage "C:\Users"
	.EXAMPLE
		Get-DiskUsage $env:OneDrive\Documents
	#>
}
Set-Alias -Name du -Value Get-DiskUsage

Function Get-ThunderBolt {
	$Thunderbolt = Get-WmiObject Win32_SystemDriver | Where-Object -Property DisplayName -Like "*Thunder*"
	If ($Thunderbolt) {
		Write-Host "The following ThunderBolt controllers have been detected:"
		$Thunderbolt
	} Else {
		Write-Host "No Thunderbolt Controllers have been detected"
	}
}

Function Get-InternetHealth {
	######### Absolute monitoring values ##########
	$maxpacketloss = 2 #how much % packetloss until we alert.
	$MinimumDownloadSpeed = 100 #What is the minimum expected download speed in Mbit/ps
	$MinimumUploadSpeed = 20 #What is the minimum expected upload speed in Mbit/ps
	$MaxJitter = 30
	######### End absolute monitoring values ######

	#Replace the Download URL to where you've uploaded the ZIP file yourself. We will only download this file once.
	#Latest version can be found at: https://www.speedtest.net/nl/apps/cli
	$DownloadURL = "https://install.speedtest.net/app/cli/ookla-speedtest-1.0.0-win64.zip"
	$DownloadLocation = "$($Env:ProgramData)\SpeedtestCLI"
	$SpeedTestExe = Join-Path -Path $DownloadLocation -ChildPath "\speedtest.exe"
	Try {
		If (!$(Test-Path $SpeedTestExe)) {
			Write-Host "Preparing Internet Health Test."
			New-Item $DownloadLocation -ItemType Directory -force
			Invoke-WebRequest -Uri $DownloadURL -OutFile "$($DownloadLocation)\speedtest.zip"
			Expand-Archive "$($DownloadLocation)\speedtest.zip" -DestinationPath $DownloadLocation -Force
		}
	} Catch {
		Write-Host "The download and extraction of SpeedtestCLI failed. Error: $($_.Exception.Message)"
		#exit 1
		Return
	}
	$PreviousResults = If (test-path "$($DownloadLocation)\LastResults.txt") { get-content "$($DownloadLocation)\LastResults.txt" | ConvertFrom-Json }
	Write-Host "Running Internet Health Test."
	$SpeedtestResults = & $SpeedTestExe --format=json --accept-license --accept-gdpr
	$SpeedtestResults | Out-File "$($DownloadLocation)\LastResults.txt" -Force
	$SpeedtestResults = $SpeedtestResults | ConvertFrom-Json

	#creating object
	[PSCustomObject]$SpeedtestObj = @{
		downloadspeed = [math]::Round($SpeedtestResults.download.bandwidth / 1000000 * 8, 2)
		uploadspeed   = [math]::Round($SpeedtestResults.upload.bandwidth / 1000000 * 8, 2)
		packetloss    = [math]::Round($SpeedtestResults.packetLoss)
		isp           = $SpeedtestResults.isp
		ExternalIP    = $SpeedtestResults.interface.externalIp
		InternalIP    = $SpeedtestResults.interface.internalIp
		UsedServer    = $SpeedtestResults.server.host
		ResultsURL    = $SpeedtestResults.result.url
		Jitter        = [math]::Round($SpeedtestResults.ping.jitter)
		Latency       = [math]::Round($SpeedtestResults.ping.latency)
	}
	$SpeedtestHealth = @()
	#Comparing against previous result. Alerting is download or upload differs more than 20%.
	If ($PreviousResults) {
		Write-Host "Comparing against previous results."
		If ($PreviousResults.download.bandwidth / $SpeedtestResults.download.bandwidth * 100 -le 80) { $SpeedtestHealth += "Download speed difference is more than 20%" } Else { $SpeedtestHealth += "Download speed appears stable" }
		If ($PreviousResults.upload.bandwidth / $SpeedtestResults.upload.bandwidth * 100 -le 80) { $SpeedtestHealth += "Upload speed difference is more than 20%" } Else { $SpeedtestHealth += "Upload speed appears stable" }
	}

	#Comparing against preset variables.
	Write-Host "Analyzing Results"
	If ($SpeedtestObj.downloadspeed -lt $MinimumDownloadSpeed) { $SpeedtestHealth += "Download speed is lower than $MinimumDownloadSpeed Mbit/ps" ; $HealthIssue = $True } Else { $SpeedtestHealth += "Download speed is acceptable" }
	If ($SpeedtestObj.uploadspeed -lt $MinimumUploadSpeed) { $SpeedtestHealth += "Upload speed is lower than $MinimumUploadSpeed Mbit/ps"  ; $HealthIssue = $True }Else { $SpeedtestHealth += "Upload speed is acceptable" }
	If ($SpeedtestObj.packetloss -gt $MaxPacketLoss) { $SpeedtestHealth += "Packetloss is higher than $maxpacketloss%"  ; $HealthIssue = $True } Else { $SpeedtestHealth += "Packet Loss is acceptable" }
	If ($SpeedtestObj.Jitter -gt $MaxJitter) { $SpeedtestHealth += "Jitter is higher than $MaxJitter%"  ; $HealthIssue = $True } Else { $SpeedtestHealth += "Jitter is acceptable" }

	Write-Host "Internet Health Test Results:"
	$SpeedtestObj | Format-Table -AutoSize -HideTableHeaders
	Write-Host "Internet Health Summary:"
	If ($HealthIssue) {Write-Host -ForegroundColor Yellow -BackgroundColor Black "There appears to be issues!" } Else { Write-Host -ForegroundColor Green -BackgroundColor Black "All tests results are optimal!"}
	$SpeedtestHealth
}

Function Get-LoginHistory {
	<#

	.SYNOPSIS
		This script reads the event log "Microsoft-Windows-TerminalServices-LocalSessionManager/Operational" from
		multiple servers and outputs the human-readable results to a CSV/Table. This data is not filterable in the
		native Windows Event Viewer.

		Version: November 9, 2016


	.SYNOPSIS
		This script reads the event log "Microsoft-Windows-TerminalServices-LocalSessionManager/Operational" from
		multiple servers and outputs the human-readable results to a CSV/Table.  This data is not filterable in
		the native Windows Event Viewer.

		NOTE: Despite this log's name, it includes both RDP logins as well as regular console logins1.

		Author:
		Mike Crowley
		https://BaselineTechnologies.com

	 .EXAMPLE

		Get-LoginHistory -ServersToQuery Server1, Server2 -StartTime "November 1"

	.LINK
		https://MikeCrowley.us/tag/powershell

	#>

	Param(
		[array]$ServersToQuery = (hostname),
		[datetime]$StartTime = "January 1, 1970"
	)

		foreach ($Server in $ServersToQuery) {

			$LogFilter = @{
				LogName = 'Microsoft-Windows-TerminalServices-LocalSessionManager/Operational'
				ID = 21, 23, 24, 25
				StartTime = $StartTime
				}

			$AllEntries = Get-WinEvent -FilterHashtable $LogFilter -ComputerName $Server

			$AllEntries | ForEach-Object {
				$entry = [xml]$_.ToXml()
				[array]$Output += New-Object PSObject -Property @{
					TimeCreated = $_.TimeCreated
					User = $entry.Event.UserData.EventXML.User
					IPAddress = $entry.Event.UserData.EventXML.Address
					EventID = $entry.Event.System.EventID
					ServerName = $Server
					}
				}
			}

		$FilteredOutput += $Output | Select-Object TimeCreated, User, ServerName, IPAddress, @{Name='Action';Expression={
					if ($_.EventID -eq '21'){"Logon"}
					if ($_.EventID -eq '22'){"Shell Start"}
					if ($_.EventID -eq '23'){"Logoff"}
					if ($_.EventID -eq '24'){"Disconnected"}
					if ($_.EventID -eq '25'){"Reconnection"}
					}
				}

		$FilteredOutput | Sort-Object -Property TimeCreated | Format-Table -AutoSize

	}

Function Install-AppDefaults {
	Write-Host "Downloading App Defaults"
	New-Item -ItemType Directory -Force -Path C:\PB\ITS247Agent
	(New-Object System.Net.WebClient).DownloadFile('https://wd.pbradshaw.net/wd/global/appdefaults.xml', 'C:\PB\AppDefaults.xml')
	Write-Host "Deploying App Defaults"
	Dism.exe /online /import-defaultappassociations:'C:\PB\AppDefaults.xml'
}

Function Install-Choco {
	Write-Host "Installing Chocolatey"
	$progressPreference = 'silentlyContinue'
	Set-ExecutionPolicy Bypass -Scope Process -Force
	Enable-SSL
	Invoke-WebRequest https://wd.pbradshaw.net/wd/global/installchoco.txt -UseBasicParsing | Invoke-Expression
}

Function Install-NetExtender {
	$App = Get-WmiObject -Class Win32_Product | Where-Object -Property "Name" -Like "*NetExtender*"

	If ($App) {
		$Name = $App.Name
		Write-Host "Uninstalling existing version of $Name"
		($App).Uninstall()
	}
	Write-Host "Downloading & Installing NetExtender"
		If (!(Get-Command choco -ErrorAction SilentlyContinue)) {Install-Choco}
		choco install sonicwall-sslvpn-netextender -y
}

Function Install-O365([String] $SiteCode = "Generic"){
	Write-Host "Downloading MS Office"
		Enable-SSL
		New-Item -ItemType Directory -Force -Path "C:\PB\O365"
		(New-Object System.Net.WebClient).DownloadFile('https://wd.pbradshaw.net/wd/global/setup.exe', 'C:\PB\O365\setup.exe')
	Write-Host "Downloading MS Office config files"
		$O365ConfigSource = "https://wd.pbradshaw.net/wd/sites/" + $SiteCode + "/" + $SiteCode + "_O365_Config.xml"
		$O365ConfigDest = "C:\PB\O365\" + $SiteCode + "_O365_Config.xml"
		(New-Object System.Net.WebClient).DownloadFile($O365ConfigSource, $O365ConfigDest)
	Write-Host "Installing Office"
		& C:\PB\O365\setup.exe /configure $O365ConfigDest | Wait-Process
	Write-Host "Placing Shortcuts"
		If (Test-Path "C:\Program Files\Microsoft Office\root\Office16\OUTLOOK.EXE"){
			$TargetFile = "C:\Program Files\Microsoft Office\root\Office16\OUTLOOK.EXE"
		} ELSEIF (Test-Path "C:\Program Files (x86)\Microsoft Office\root\Office16\OUTLOOK.EXE"){
			$TargetFile = "C:\Program Files (x86)\Microsoft Office\root\Office16\OUTLOOK.EXE"
		}
		$ShortcutFile = "$env:Public\Desktop\Outlook.lnk"
		$WScriptShell = New-Object -ComObject WScript.Shell
		$Shortcut = $WScriptShell.CreateShortcut($ShortcutFile)
		$Shortcut.TargetPath = $TargetFile
		$Shortcut.Save()

		If (Test-Path "C:\Program Files\Microsoft Office\root\Office16\EXCEL.EXE"){
			$TargetFile = "C:\Program Files\Microsoft Office\root\Office16\EXCEL.EXE"
		} ELSEIF (Test-Path "C:\Program Files (x86)\Microsoft Office\root\Office16\EXCEL.EXE"){
			$TargetFile = "C:\Program Files (x86)\Microsoft Office\root\Office16\EXCEL.EXE"
		}
		$ShortcutFile = "$env:Public\Desktop\Excel.lnk"
		$WScriptShell = New-Object -ComObject WScript.Shell
		$Shortcut = $WScriptShell.CreateShortcut($ShortcutFile)
		$Shortcut.TargetPath = $TargetFile
		$Shortcut.Save()

		If (Test-Path "C:\Program Files\Microsoft Office\root\Office16\WINWORD.EXE"){
			$TargetFile = "C:\Program Files\Microsoft Office\root\Office16\WINWORD.EXE"
		} ELSEIF (Test-Path "C:\Program Files (x86)\Microsoft Office\root\Office16\WINWORD.EXE"){
			$TargetFile = "C:\Program Files (x86)\Microsoft Office\root\Office16\WINWORD.EXE"
		}
		$ShortcutFile = "$env:Public\Desktop\Word.lnk"
		$WScriptShell = New-Object -ComObject WScript.Shell
		$Shortcut = $WScriptShell.CreateShortcut($ShortcutFile)
		$Shortcut.TargetPath = $TargetFile
		$Shortcut.Save()
}

Function Install-O365ProofPointConnectors {
<#
	.SYNOPSIS
		Installs the proofpoint inbound and outbound connectors in exchange online, as well as spam bypass for emails coming from exchange.
#>
	If (Get-Command Get-Mailbox -ErrorAction SilentlyContinue){
		Function Install-ProofPointInbound {
			New-InboundConnector -Name “Inbound from ProofPoint” -Comment “Only accept email from ProofPoint transport addresses” -Enabled $True  -SenderDomains * -RestrictDomainsToIPAddresses $true -RequireTls $true -SenderIPAddresses 148.163.159.0/24, 148.163.158.0/24, 148.163.157.0/24, 148.163.156.0/24, 148.163.155.0/24, 148.163.154.0/24, 148.163.153.0/24, 148.163.151.0/24, 148.163.150.0/24, 148.163.149.0/24, 148.163.148.0/24, 148.163.147.0/24, 148.163.146.0/24, 148.163.145.0/24, 148.163.143.0/24, 148.163.142.0/24, 148.163.141.0/24, 148.163.140.0/24, 148.163.139.0/24, 148.163.138.0/24, 148.163.137.0/24, 148.163.135.0/24, 148.163.134.0/24, 148.163.133.0/24, 148.163.132.0/24, 148.163.131.0/24, 148.163.130.0/24, 148.163.129.0/24, 52.54.85.198, 52.55.243.18, 34.192.199.2, 67.231.156.0/24, 67.231.155.0/24, 67.231.154.0/24, 67.231.153.0/24, 67.231.152.0/24, 67.231.148.0/24, 67.231.147.0/24, 67.231.146.0/24, 67.231.145.0/24, 67.231.144.0/24, 148.163.152.0/24, 148.163.144.0/24, 148.163.136.0/24, 148.163.128.0/24, 67.231.149.0/24
		}

		Function Install-ProofPointOutbound {
			New-OutboundConnector -Name “Outbound to ProofPoint” -Comment “Send all external outbound email through ProofPoint SmartHost” -Enabled $true -RecipientDomains * -SmartHosts outbound-us1.ppe-hosted.com -TlsSettings EncryptionOnly -UseMXRecord $false
		}

		If (Get-InboundConnector) {
			$Readhost = Read-Host "Warning, an inbound connector already exists.`nAre you sure you want to install the ProofPoint connector which may conflict?`n( y / n ) "
			Switch ($ReadHost)
			{
				Y { Write-Host "Installing the Proofpoint Inbound Connector.";Install-ProofPointInbound }
				N { break }
				Default { "You didn't enter the a correct response" }
			}
		} else {
			Write-Host "Installing the Proofpoint Inbound Connector."
			Install-ProofPointInbound
		}

		If (Get-OutboundConnector) {
			$Readhost = Read-Host "Warning, an outbound connector already exists.`nAre you sure you want to install the ProofPoint connector which may conflict? ( y / n ) "
			Switch ($ReadHost)
			{
				Y { Write-Host "Installing the Proofpoint Outbound Connector.";Install-ProofPointOutbound }
				N { break }
				Default { "You didn't enter the a correct response" }
			}
		} Else {
			Write-Host "Installing the Proofpoint Outbound Connector."
			Install-ProofPointOutbound
		}

		Set-HostedConnectionFilterPolicy “Default” -IPAllowList 148.163.147.0/24, 148.163.146.0/24, 148.163.145.0/24, 148.163.143.0/24, 148.163.142.0/24, 148.163.141.0/24, 148.163.140.0/24, 148.163.139.0/24, 148.163.138.0/24, 148.163.137.0/24, 148.163.135.0/24, 148.163.134.0/24, 148.163.133.0/24, 148.163.132.0/24, 148.163.131.0/24, 148.163.130.0/24, 148.163.129.0/24, 52.54.85.198, 52.55.243.18, 34.192.199.2, 67.231.156.0/24, 67.231.155.0/24, 67.231.154.0/24, 67.231.153.0/24, 67.231.152.0/24, 67.231.148.0/24, 67.231.147.0/24, 67.231.146.0/24, 67.231.145.0/24, 67.231.144.0/24, 148.163.152.0/24, 148.163.144.0/24, 148.163.136.0/24, 148.163.128.0/24, 67.231.149.0/24 -EnableSafeList $True
		Set-HostedContentFilterPolicy -Identity "Default" -AddXHeaderValue "Office 365 Notice: Possible Spam" -AdminDisplayName "Disabled 365 Filtering, inbound handled by Proofpoint." -BulkSpamAction "NoAction" -BulkThreshold 9 -DownloadLink $False -EnableEndUserSpamNotifications $False -EnableLanguageBlockList $False -EnableRegionBlockList $False -HighConfidencePhishAction MoveToJmf -HighConfidenceSpamAction AddXHeader -IncreaseScoreWithBizOrInfoUrls Off -IncreaseScoreWithImageLinks Off -IncreaseScoreWithNumericIps Off -IncreaseScoreWithRedirectToOtherPort Off -InlineSafetyTipsEnabled $False -MakeDefault -MarkAsSpamBulkMail Off -MarkAsSpamEmbedTagsInHtml Off -MarkAsSpamEmptyMessages Off -MarkAsSpamFormTagsInHtml Off -MarkAsSpamFramesInHtml Off -MarkAsSpamFromAddressAuthFail Off -MarkAsSpamJavaScriptInHtml Off -MarkAsSpamNdrBackscatter Off -MarkAsSpamObjectTagsInHtml Off -MarkAsSpamSensitiveWordList Off -MarkAsSpamSpfRecordHardFail Off -MarkAsSpamWebBugsInHtml Off -PhishSpamAction AddXHeader -PhishZapEnabled $False -QuarantineRetentionPeriod 30 -RedirectToRecipients $Null -RegionBlockList $Null -SpamAction AddXHeader -SpamZapEnabled $False -TestModeAction None -TestModeBccToRecipients $Null
		$DisableMailoxJunkFilters = Get-ExoMailbox -RecipientTypeDetails UserMailbox -ResultSize Unlimited; $All | ForEach-Object {Set-MailboxJunkEmailConfiguration $_.Name -Enabled $false}
	} Else {
		Write-Host "You are not connected to an exchange server. Try the command 'Connect-O365Exchange'."
	}
}

Function Install-WinGet {
<#
	.SYNOPSIS
		Installs winget, Microsoft's answer to apt-get and choco.
	.LINK
		https://github.com/microsoft/winget-cli
	.LINK
		https://docs.microsoft.com/en-us/windows/package-manager/winget/
#>
	$WGLatestWeb = Invoke-WebRequest https://github.com/microsoft/winget-cli/releases/latest -UseBasicParsing
	$WGLatestLink = "https://github.com" + ($WGLatestWeb.Links | Where-Object {$_.href -like "*msixbundle*"}).href

	$GetWinGet = {
		$WGLatestWeb = Invoke-WebRequest https://github.com/microsoft/winget-cli/releases/latest -UseBasicParsing
		$WGLatestLink = "https://github.com" + ($WGLatestWeb.Links | Where-Object {$_.href -like "*msixbundle*"}).href
		Write-Host "Installing the latest version of winget from:`n $WGLatestLink"
		$DownloadURL = $WGLatestLink
		$DownloadLocation = "$env:TEMP\"
		$LocalFilePath = Join-Path -Path $DownloadLocation -ChildPath "Microsoft.DesktopAppInstaller_8wekyb3d8bbwe.msixbundle"
		If (Test-Path $LocalFilePath) {Remove-Item -Path $LocalFilePath -Force -ErrorAction SilentlyContinue}
		Write-Host "Downloading Desktop App Installer"
		$progressPreference = 'silentlyContinue'
		Invoke-WebRequest -Uri $DownloadURL -OutFile $LocalFilePath

		Add-AppxPackage -Path $LocalFilePath
		Remove-Item -Path $LocalFilePath -Force -ErrorAction SilentlyContinue
	}

	$GetWinGetDependancies = {
		Write-Host "Checking Dependancies"
		## C++ Runtime framework packages for Desktop Bridge - https://docs.microsoft.com/en-us/troubleshoot/cpp/c-runtime-packages-desktop-bridge#how-to-install-and-update-desktop-framework-packages
		## x86 version
		$Installed_X86_VCLibs = Get-AppxPackage | Where-Object {$_.Name -Match "Microsoft.VCLibs.140.00.UWPDesktop" -and $_.Architecture -Match "X86"}
		If (-not ($Installed_X86_VCLibs)) {
			$DownloadURL = 'https://aka.ms/Microsoft.VCLibs.x86.14.00.Desktop.appx'
			$DownloadLocation = "$env:TEMP\"
			$LocalFilePath = Join-Path -Path $DownloadLocation -ChildPath "Microsoft.VCLibs.x86.14.00.Desktop.appx"
			If (Test-Path $LocalFilePath) {Remove-Item -Path $LocalFilePath -Force -ErrorAction SilentlyContinue}
			Write-Host "Downloading $DownloadURL"
			$progressPreference = 'silentlyContinue'
			Invoke-WebRequest -Uri $DownloadURL -OutFile $LocalFilePath
			If ($PSVersionTable.PSEdition -eq "Core") {Import-module "Appx" -UseWindowsPowerShell}
			Write-Host "Installing $LocalFilePath"
			Add-AppxPackage -Path $LocalFilePath
			Remove-Item -Path $LocalFilePath -Force -ErrorAction SilentlyContinue
		}
		## x64 version
		If ([Environment]::Is64BitOperatingSystem){
			$Installed_X64_VCLibs = Get-AppxPackage | Where-Object {$_.Name -Match "Microsoft.VCLibs.140.00.UWPDesktop" -and $_.Architecture -Match "X64"}
			If (-not ($Installed_X64_VCLibs)) {
				$DownloadURL = 'https://aka.ms/Microsoft.VCLibs.x64.14.00.Desktop.appx'
				$DownloadLocation = "$env:TEMP\"
				$LocalFilePath = Join-Path -Path $DownloadLocation -ChildPath "Microsoft.VCLibs.x64.14.00.Desktop.appx"
				If (Test-Path $LocalFilePath) {Remove-Item -Path $LocalFilePath -Force -ErrorAction SilentlyContinue}
				Write-Host "Downloading $DownloadURL"
				$progressPreference = 'silentlyContinue'
				Invoke-WebRequest -Uri $DownloadURL -OutFile $LocalFilePath
				If ($PSVersionTable.PSEdition -eq "Core") {Import-module "Appx" -UseWindowsPowerShell}
				Write-Host "Installing $LocalFilePath"
				Add-AppxPackage -Path $LocalFilePath
				Remove-Item -Path $LocalFilePath -Force -ErrorAction SilentlyContinue
			}
		}
	}

	If ($(whoami) -eq "nt authority\system") {
		Write-Error "Due to the AppX nature of Winget, you cannot run this as the system user"
	} ElseIf (!(Get-process -Name Explorer -IncludeUserName | Where-Object -Property UserName -EQ $(whoami))){
		Write-Error "Due to the AppX nature of Winget, you cannot install WinGet when running the command as a user that is not logged in"
	} Else {
# Install WinGet
		If (Get-Command winget -ErrorAction SilentlyContinue) {
			Write-Host "WinGet is already installed."
			$WGVersion = winget -v
			If ($WGLatestLink -match $WGVersion) {
				Write-Host "The installed version $WGVersion is up to date."
			} Else {
				Write-Host "The installed version $WGVersion is out of date."
				If ($PSVersionTable.PSEdition -eq "Core") {Powershell.exe -NonInteractive -Command $GetWinGet} Else {$GetWinGet | Invoke-Expression}
				$WGVersion2 = winget -v
				If ($WGVersion -ne $WGVersion2) {
					Write-Host "Winget $WGVersion2 installed successfully"
				} Else {
					Write-Error "Winget did not install successfully"
				}
			}
		} Else {
			Write-Host "WinGet is not installed."
			If ($PSVersionTable.PSEdition -eq "Core") {Powershell.exe -NonInteractive -Command $GetWinGetDependancies} Else {$GetWinGetDependancies | Invoke-Expression}
			If ($PSVersionTable.PSEdition -eq "Core") {Powershell.exe -NonInteractive -Command $GetWinGet} Else {$GetWinGet | Invoke-Expression}
			If (Get-Command winget -ErrorAction SilentlyContinue) {
				$WGVersion = winget -v
				Write-Host "Winget $WGVersion installed successfully"
			} Else {
				Write-Error "Winget did not install successfully"
			}
		}
	}
}

Function Install-WinGetApps {
	Install-WinGet
	Winget install -e --id 7zip.7zip -h
	Winget install -e --id Google.Chrome -h
	Winget install -e --id Mozilla.FirefoxESR -h
	Winget install -e --id Zoom.Zoom -h
	Winget install -e --id Notepad++.Notepad++ -h
	Winget install -e --id Adobe.AdobeAcrobatReaderDC -h
	Winget install -e --id VideoLAN.VLC -h
	Winget install -e --id Microsoft.PowerShell -h
}

Function Install-WinRepairToolbox {
	Write-Host "Downloading Windows Repair Toolbox"
		$URL = 'https://windows-repair-toolbox.com/files/Windows_Repair_Toolbox.zip'
		$DLFolder = $ENV:SystemDrive + '\PB\Windows_Repair_Toolbox'
		$DLFilePath = $DLFolder + '\Windows_Repair_Toolbox.zip'
		$null = (New-Item -ItemType Directory -Force -Path $DLFolder)
		(New-Object System.Net.WebClient).DownloadFile($url, $DLFilePath)
	Write-Host "Expanding Windows Repair Toolbox"
		Expand-Archive -Path $DLFilePath -DestinationPath $DLFolder -Force
	Write-Host "Downloading Windows Repair Toolbox Customizations"
		$URL = 'https://wd.pbradshaw.net/wd/global/Windows_Repair_Toolbox_Custom.zip'
		$CustomizationFilePath = $DLFolder + '\Windows_Repair_Toolbox_Custom.zip'
		$null = (New-Item -ItemType Directory -Force -Path $DLFolder)
		(New-Object System.Net.WebClient).DownloadFile($url, $CustomizationFilePath)
	Write-Host "Customizing Windows Repair Toolbox"
		Expand-Archive -Path $CustomizationFilePath -DestinationPath $DLFolder -Force
	Write-Host "Cleaning up downloaded files"
	Remove-Item -Path $DLFilePath -Force
	Remove-Item -Path $CustomizationFilePath -Force
	"& $($DLFolder + '\Windows_Repair_Toolbox.exe')" | Clip
	Write-Host "The command to launch Windows Repair Toolbox has been put in your clipboard."
}

Function Invoke-Win10Decrap {
	Write-Host "Windows 10 Decrapifier"
	$progressPreference = 'silentlyContinue'
	Set-ExecutionPolicy Bypass -Scope Process -Force
	Enable-SSL
	Invoke-WebRequest https://wd.pbradshaw.net/wd/global/windows10decrapifier.txt -UseBasicParsing | Invoke-Expression
}

Function Join-Domain {
		param
	(
		[Parameter(Mandatory=$true)]
		[string]$Domain,
		[Parameter(Mandatory=$true)]
		[string]$Username,
		[Parameter(Mandatory=$true)]
		$Password
	)
	Write-Host "Join Domain"
	$Password = $Password | ConvertTo-SecureString -asPlainText -Force
	$Username = $Domain + "\" + $Username
	$credential = New-Object System.Management.Automation.PSCredential($Username,$Password)
	Add-Computer -DomainName $Domain -Credential $credential
}

Function Remove-ITS247InstallFolder {
	Write-Host "Cleaning up install folder"
	Remove-PathForcefully -Path 'C:\PB\ITS247Agent'
}

Function Optimize-Powershell {
	$Commands = @()
	$Commands = {
	Function prompt {
			$date = Get-Date
			$time = $date.GetDateTimeFormats()[88]
			$curdir = $ExecutionContext.SessionState.Path.CurrentLocation #.Path.Split('\')[-1]
			If ($curdir.Length -eq 0) {$curdir = $ExecutionContext.SessionState.Drive.Current.Name+':\'}
			Write-Host ''$env:USERNAME'@'$env:COMPUTERNAME' |' -NoNewLine -BackgroundColor Black -ForegroundColor Yellow
			Write-Host ' DIR:'$curdir' |' -NoNewLine -BackgroundColor Black -ForegroundColor Yellow
			Write-Host ''$time' ' -BackgroundColor Black -ForegroundColor Yellow
			'[Command]: '
		}
		Invoke-WebRequest https://wd.pbradshaw.net/wd/global/functions.txt -useb  | Invoke-Expression
		Clear-Host
		Write-Host "`n`nWelcome PB TechGod, I await your command...`n`n"
	}
	#Source code can be found at: https://github.com/Microsoft/Terminal/tree/master/src/tools/ColorTool
	$DownloadURL = "https://raw.githubusercontent.com/waf/dracula-cmd/master/dist/ColorTool.zip"
	$DownloadLocation = "C:\PB\ColorTool"
	$DownloadFile = "$($DownloadLocation)\ColorTool.zip"
	$InstallExe = Join-Path -Path $DownloadLocation -ChildPath "\ColorTool\install.cmd"
	
	Try {
		If (!$(Test-Path $InstallExe)) {
			#Write-Host "Preparing Internet Health Test."
			New-Item $DownloadLocation -ItemType Directory -force
			Invoke-WebRequest -Uri $DownloadURL -OutFile $DownloadFile
			Expand-Archive $DownloadFile -DestinationPath $DownloadLocation -Force
			$Content = Get-Content $InstallExe
			$Content | Foreach-Object {$_ -replace [regex]::escape('pause'), ''} | Set-Content $InstallExe
			& $InstallExe
			$NewCommands = (Invoke-WebRequest https://raw.githubusercontent.com/dracula/powershell/master/theme/dracula-prompt-configuration.ps1 -UseBasicParsing).Content #
			$Commands = $Commands ; $NewCommands
			$Commands | Set-Content $Profile
			$Null = New-ItemProperty -LiteralPath 'HKCU:\Console' -Name 'FaceName' -Value 'Consolas' -PropertyType String -Force -ea SilentlyContinue
		}
	} Catch {
		Write-Host "The download and extraction of ColorTool failed. Error: $($_.Exception.Message)"
		#exit 1
		Return
	}
	Start-Process C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -ArgumentList "-NoExit -Mta -WindowStyle Maximized -Command $Commands"
}

Function Remove-PathForcefully {
	param(
		[parameter(Mandatory=$true)]
		[string] $Path
	)
	<# the code below has been used from
		- https://blogs.technet.com/b/heyscriptingguy/archive/2013/10/19/weekend-scripter-use-powershell-and-pinvoke-to-remove-stubborn-files.aspx
	with inspiration from
		- http://www.leeholmes.com/blog/2009/02/17/moving-and-deleting-really-locked-files-in-powershell/
	and error handling from
		- https://blogs.technet.com/b/heyscriptingguy/archive/2013/06/25/use-powershell-to-interact-with-the-windows-api-part-1.aspx
	#>
	Add-Type -ErrorAction Ignore @'
		using System;
		using System.Text;
		using System.Runtime.InteropServices;

		public class Posh
		{
			public enum MoveFileFlags
			{
				MOVEFILE_DELAY_UNTIL_REBOOT = 0x00000004
			}

			[DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
			static extern bool MoveFileEx(string lpExistingFileName, string lpNewFileName, MoveFileFlags dwFlags);

			public static bool MarkFileDelete (string sourcefile)
			{
				return MoveFileEx(sourcefile, null, MoveFileFlags.MOVEFILE_DELAY_UNTIL_REBOOT);
			}
		}
'@
	Function Remove-SubPath {
		param(
			[parameter(Mandatory=$true)]
			[string] $SubPath
		)


		$SubPath = (Resolve-Path $SubPath -ErrorAction Stop).Path
		try {
			Remove-Item $SubPath -Force -Recurse -ErrorAction Stop
			Write-Host -ForegroundColor Green -BackgroundColor Black "Deletion of $SubPath succeeded."
		} catch {
			$deleteResult = [Posh]::MarkFileDelete($SubPath)
			if ($deleteResult -eq $false) {
				throw (New-Object ComponentModel.Win32Exception) # calls GetLastError
			} else {
				Write-Host -ForegroundColor Red -BackgroundColor Yellow "Deletion of ||$SubPath|| failed. Deleting at next boot."#`n$($_.Exception.Message)"
			}
		}
	}
	If (Test-Path -Path $Path -Verbose) {
		$SubFiles = Get-ChildItem -Path $Path -Recurse -Force -File
		$SubFolders = Get-ChildItem -Path $Path -Recurse -Force -Directory
		If ($SubFiles -or $SubFolders) {
			$SubFiles | ForEach-Object {Remove-SubPath -SubPath $_.FullName}
			$SubFolders | ForEach-Object {Remove-SubPath -SubPath $_.FullName}
			Remove-SubPath -SubPath $Path
		} Else {
			Remove-SubPath -SubPath $Path
		}
	} Else {
		Write-Warning "$Path was not found."
	}
	<#
	.SYNOPSIS
		Deletes all files and folders given immediately if they are not locked.
		If locked files are found, queues them up to be deleted upon next reboot.
		Recurse is assumed.
	.PARAMETER Path
		The file system path of the folder or file to be deleted.
	.EXAMPLE
		Remove-PathForcefully -Path "C:\Temp" # Deletes the folder C:\Temp and all files or folders within, queuing up any locked files for deletion on next reboot.
	#>
}

Function Remove-PPKGInstallFolder {
	Write-Host "Cleaning up and Restarting Computer"
	PowerShell.exe -NoProfile -ExecutionPolicy Bypass -Command "If (Test-Path C:\IT\PPKG){Remove-Item -LiteralPath 'C:\IT\PPKG' -Force -Recurse};Restart-Computer -Force"
	Stop-transcript
	Restart-Computer -Force
}

Function Rename-ClientComputer {
	Write-Host "Rename Computer"
		$title = 'Rename Computer'
		$msg = 'Enter the client shortcode (e.g. AAIHB) or Dept code'
		$SerialNumber = (Get-WmiObject win32_bios).SerialNumber
		#Message box prompts onscreen for input
		[void][Reflection.Assembly]::LoadWithPartialName('Microsoft.VisualBasic')
		$ClientCode = [Microsoft.VisualBasic.Interaction]::InputBox($msg, $title)
		Rename-Computer ($ClientCode + "-" + $SerialNumber) -Force
	Write-Host "End of Rename Computer"
}

Function Repair-O365AppIssues {
	Write-Host "Please note this is an interactive tools, to be run from a user's session."
	If (-not (Test-Path 'C:\PB')) {New-Item -ItemType Directory -Force -Path C:\PB\ | Out-Null}
	(New-Object System.Net.WebClient).DownloadFile('https://aka.ms/SaRASetup', 'C:\PB\SaraSetup.exe')
	& C:\PB\SaraSetup.exe
	Write-Host "SaRA should now be installing, please wait a moment as it launces."
<#
	.SYNOPSIS
		Downloads and runs the Microsoft Support and Recovery Assistant (SaRA) tool.
		Please note this is an interactive tools, to be run from a user's session.
	.LINK
		https://www.thewindowsclub.com/microsoft-support-and-recovery-assistant
	.LINK
		https://www.microsoft.com/en-us/download/100607
#>
}

Function Repair-Windows {
	$StartTime = (Get-Date)
	(Get-Date).DateTime | Out-Host
	Write-Host Repair-Volume -DriveLetter $Env:SystemDrive.SubString(0,1) -Scan
	$chdksk = Repair-Volume -DriveLetter $Env:SystemDrive.SubString(0,1) -Scan
	If ($chdksk -ne "NoErrorsFound") {Repair-Volume -DriveLetter $Env:SystemDrive.SubString(0,1) -SpotFix}
	Write-Host Dism /Online /Cleanup-Image /StartComponentCleanup
	Dism /Online /Cleanup-Image /StartComponentCleanup
	Write-Host ...
	(Get-Date).DateTime | Out-Host
	Write-Host Dism /Online /Cleanup-Image /RestoreHealth
	Dism /Online /Cleanup-Image /RestoreHealth
	Write-Host ...
	(Get-Date).DateTime | Out-Host
	Write-Host SFC /scannow
	SFC /scannow
	(Get-Date).DateTime | Out-Host
	$EndTime = (Get-Date) - $StartTime
	Write-Host "This process took:"
	$EndTime | Format-Table | Out-Host
	Write-Host "Run this function repeately until no errors show up. If this fails after 3 tries, upgrade or reinstall windows"
}

Function Restore-LastUser {
	$RegKey = "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Authentication\LogonUI"
	$RegKeyPS = "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Authentication\LogonUI"
	$RegFile = "C:\PB\LastLoggedOnUser.reg"
	$InitUser = (Get-ItemProperty $RegKeyPS).LastLoggedOnUser

	If (Test-Path -Path $RegFile){
		$User = (Select-String -Path $RegFile -Pattern '"LastLoggedOnUser"' -SimpleMatch).Line
		Write-Host "Restoring:`n$User"
		REG IMPORT $RegFile
		$NewUser = (Get-ItemProperty $RegKeyPS).LastLoggedOnUser
		Write-Host "Last Logged On User has been restored from $InitUser to $NewUser"
		Write-Host "Refreshing the Logon Screen."
		Get-Process -Name LogonUI -ErrorAction SilentlyContinue | Stop-Process -Force
	} Else {
		Write-Host "Error: No backup exists. Try the command Backup-LastUser to create a backup."
	}
}

Function Set-AutoLogon ([String] $SiteCode) {
	Write-Host "Set autologon"
		#Registry path declaration
		$RegPath = "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon"
		[String]$DefaultUsername = 'ITSupport'
		[String]$DefaultPassword = $SiteCode + 'T3mpP@ss'
		#setting registry values
		Set-ItemProperty $RegPath "AutoAdminLogon" -Value "1" -type String
		Set-ItemProperty $RegPath "DefaultUsername" -Value $DefaultUsername -type String
		Set-ItemProperty $RegPath "DefaultPassword" -Value $DefaultPassword -type String
		Set-ItemProperty $RegPath "AutoLogonCount" -Value "1" -type DWord
	Write-Host "End of Set autologon"
}

Function Set-DailyReboot {
<#
	.SYNOPSIS
		Creates a scheduled task to restart the computer daily at 3am, if no one is using the computer.
		Helpful for maintaining updated and stability.
#>
	Write-Host "Schedule Daily Restart"
		$Action = New-ScheduledTaskAction -Execute 'shutdown.exe' -Argument '-f -r -t 0'
		$Trigger = New-ScheduledTaskTrigger -Daily -At 3am
		$Idle = New-ScheduledTaskSettingsSet -RunOnlyIfIdle -IdleDuration 00:30:00 -IdleWaitTimeout 02:00:00
		$User = "NT AUTHORITY\SYSTEM"
		Register-ScheduledTask -Action $action -Trigger $trigger -User $User -Settings $Idle -TaskName "Daily Restart" -Description "Daily restart" -Force | Out-Null
		$NewDate = (Get-ScheduledTask -TaskName "Daily Restart").Triggers.StartBoundary.subString(0,16)
	Write-Host "The next scheduled 'Daily Restart' task will happen at $([Datetime]::ParseExact($NewDate, 'yyyy-MM-ddTHH:mm', $null))"
}

Function Set-DailyRebootDelay {
<#
	.SYNOPSIS
		Delays the "Daily Restart" scheduled task by the specified numer of days
	.PARAMETER Days
		The number of days to delay the reboot
	.EXAMPLE
		'Set-DailyRebootDelay -Days 80' will delay nightly reboots for 80 days!
#>
	param
	(
		[Parameter(Mandatory=$true)]
		[Int32]$Days
	)
	$DailyRebootTask = Get-ScheduledTask -TaskName "Daily Restart" -ErrorAction SilentlyContinue
	If (! $DailyRebootTask) {
		Set-DailyReboot
	}
	$DelayedStart = (Get-Date).AddDays($Days).ToString('yyyy-MM-dd') + "T03:00:00-06:00"
	$Trigger = New-ScheduledTaskTrigger -Daily -At 3am
	$Trigger.StartBoundary = $DelayedStart
	$DailyRebootTask.Triggers = $Trigger
	$DailyRebootTask | Set-ScheduledTask | Out-Null
	$NewDate = (Get-ScheduledTask -TaskName "Daily Restart").Triggers.StartBoundary.subString(0,16)
	Write-Host "The next scheduled 'Daily Restart' task will happen at $([Datetime]::ParseExact($NewDate, 'yyyy-MM-ddTHH:mm', $null))"
}

Function Set-Time {
	Write-Host "Setting local time zone to GMT Standard Time"
	Set-TimeZone -Name "GMT Standard Time"
	net start W32Time
	W32tm /resync /force
}

Function Set-NumLock {
	Write-Host "Setting Numlock on keyboard as default"
	Set-ItemProperty -Path 'Registry::HKU\.DEFAULT\Control Panel\Keyboard' -Name "InitialKeyboardIndicators" -Value "2" -Force -PassThru
}

Function Set-RunOnceScript {
	param
	(
		[string]$Label,
		[string]$Script
	)

	$RunOnceValue = 'PowerShell.exe -ExecutionPolicy Bypass -File "' + $Script + '"'
	Write-Host "Install After Reboot"
	Set-ItemProperty 'HKLM:\Software\Microsoft\Windows\CurrentVersion\RunOnce' -Name $Label -Value $RunOnceValue
}

Function Start-PPKGLog ([String] $LogLabel) {
	Write-Host "Making a log file for debugging"
		$LogPath = "C:\PB\" + $SiteCode + "-" + $LogLabel + ".log"
		Start-Transcript -path $LogPath -Force -Append
}

Function Update-Edge {
	Write-Host "Updating Microsoft Edge"
	If (!(Get-Command choco -ErrorAction SilentlyContinue)) {Install-Choco}
	If (Get-Process MicrosoftEdge -ErrorAction SilentlyContinue) {Get-Process MicrosoftEdge | Stop-Process -Force}
	Choco upgrade microsoft-edge -y
}

Function Update-Everything {
	Write-Warning "Update-Everything will have a visible impact to any logged in users,`nas it will update drivers and reboot the computer.`nYou have 10 seconds to press CTRL+C to cancel this function."
	$delay = 10

	while ($delay -ge 0)
	{
		Write-Host "$delay seconds left to cancel"
		Start-Sleep 1
		$delay --
	}
	$delay = $null
	If (!(Get-Command choco -ErrorAction SilentlyContinue)) {choco upgrade all -y}
	Update-Windows
	Update-DellPackages
	Update-Edge
	Update-NiniteApps
	Update-PWSH
	Restart-Computer -Force
}

Function Update-O365Apps {
	$global:O365CurrentCdn = ""
	If (-not (Test-Path 'C:\Program Files\Common Files\Microsoft Shared\ClickToRun\OfficeC2RClient.exe')) {
		Write-Host "Office 365 Click2Run is not installed. This script does not apply."
	} Else {
		$Apps = @('Excel','Outlook','WinWord','PowerPoint','MsAccess','MSPub','OneNote')
		$OpenApps = @('')
		$Apps | ForEach-Object {
			If (Get-Process $_ -ErrorAction SilentlyContinue) {
				$OpenApps = $OpenApps += $_
			}
		}

		If ($OpenApps) {
			Write-Host "Aborting update, the following Office Apps are open:"
			$OpenApps | Format-List | Out-String
			Write-Host "Please close these programs and try again."
			} Else {
			Function Get-Office365Version {
				$O365CurrentVer = ""
				$O365CurrentCdn = ""
				$O365CurrentPol = ""
				$O365CurrentVer = (Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Office\ClickToRun\Configuration" -ErrorAction SilentlyContinue).VersionToReport
				$O365CurrentCdn = (Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Office\ClickToRun\Configuration" -ErrorAction SilentlyContinue).CDNBaseUrl
				$O365CurrentPol = (Get-ItemProperty -Path "HKLM:\SOFTWARE\policies\microsoft\office\16.0\common\officeupdate" -ErrorAction SilentlyContinue).updatebranch
				if ($O365CurrentVer.Length -eq 0) {
					Write-Host "Office 365 (C2R) is not installed on this PC."
				} else {
					Write-Host "Office 365 (C2R) Current Version: "$O365CurrentVer
					switch ($O365CurrentCdn) {
						"http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60" {$O365CurrentCdn = "Monthly Channel"}
						"http://officecdn.microsoft.com/pr/7ffbc6bf-bc32-4f92-8982-f9dd17fd3114" {$O365CurrentCdn = "Semi-Annual Channel"}
						"http://officecdn.microsoft.com/pr/b8f9b850-328d-4355-9145-c59439a0c4cf" {$O365CurrentCdn = "Semi-Annual Channel (Targeted)"}
					}
					Write-Host "Office 365 Update Channel (Local Setting): "$O365CurrentCdn
					if ($O365CurrentPol.length -eq 0) {
						$O365CurrentPol = "None"
					} else {
						switch ($O365CurrentPol) {
							"Current" {$O365CurrentPol = "Monthly Channel"}
							"Deferred" {$O365CurrentPol = "Semi-Annual Channel"}
							"FirstReleaseDeferred" {$O365CurrentPol = "Semi-Annual Channel (Targeted)l"}
						}
					}
					Write-Host "Office 365 Update Channel (Policy Setting): "$O365CurrentPol
					Write-Host "`n"
				}
			}

			Function Wait-UpdateStop {
				param
				(
					[Parameter(Mandatory=$False)]
					[string]$Process
				)

				Function Get-SpecificProcess {
					Get-Process OfficeClickToRun -ErrorAction SilentlyContinue | Where-Object -Property Path -Like "*Microsoft Shared\ClickToRun\Updates\*"
				}

				$Timeout = 190 ## seconds
				Try {
					$timer = [Diagnostics.Stopwatch]::StartNew()
					while (($timer.Elapsed.TotalSeconds -lt $Timeout) -and (-not (Get-SpecificProcess))) {
						Start-Sleep -Seconds 2
						$totalSecs = [math]::Round($timer.Elapsed.TotalSeconds, 0)
						Write-Verbose -Message "Still waiting for action to complete after [$totalSecs] seconds..."
					}
					$timer.Stop()
					if ($timer.Elapsed.TotalSeconds -gt $Timeout) {
						Write-Host "Office update either failed or is already up to date"
					} else {
						Do {
							If (!(Get-SpecificProcess)) {
								   Write-Host "Waiting for $Process to Start"
								   Start-Sleep -Seconds 2
							} Else {
							   Write-Host "$Process has Started"
							   While (Get-SpecificProcess) {
										[String]$CPU = (Get-SpecificProcess).CPU
										If ($CPU.Length -gt 4) {$CPU = $CPU.substring(0,4)}
										Write-Host -NoNewLine "`rWaiting for $Process to stop. CPU time = $CPU"
										Start-Sleep -Seconds 5
							   }
							   Write-Host "`n`n$Process Stopped" ; $Status = 'Done'
							}
						} Until ($Status)
					}
				} Catch {
					Write-Error -Message $_.Exception.Message
				}
			}

			Get-Office365Version

			If (!($O365CurrentCdn -like "*monthlty*")) {
				Write-Host "Setting update channel to monthly"
				& "C:\Program Files\Common Files\Microsoft Shared\ClickToRun\OfficeC2RClient.exe" /changesetting Channel=Current
			}

			Write-Host "Updating Office, please wait 120 seconds to see further progress."
				& "C:\Program Files\Common Files\Microsoft Shared\ClickToRun\OfficeC2RClient.exe" /update user updatepromptuser=false forceappshutdown=true displaylevel=false
				Restart-Service -Name "ClickToRunSvc" -Force -ErrorAction SilentlyContinue
				Wait-UpdateStop OfficeClickToRun

				Write-Host "`n"

			Get-Office365Version
		}
	}
}

Function Update-PowershellModules {
	Set-ExecutionPolicy RemoteSigned -Scope Process -Force
	[Net.ServicePointManager]::SecurityProtocol = [Net.ServicePointManager]::SecurityProtocol -bor [Net.SecurityProtocolType]::Tls12
	$Providers = (Get-PackageProvider).Name
	If ($Providers -NotContains "Nuget") {
		Install-PackageProvider -Name NuGet -Force -ErrorAction SilentlyContinue
	}
	$Modules = Get-Module
	$ModulesToInstall = "PSReadline","PowerShellGet"
	$ModulesToInstall | ForEach-Object {
		$Mod = $_
		Remove-Module $Mod -Force -ErrorAction SilentlyContinue -WarningAction SilentlyContinue
		Uninstall-Module $Mod -Force -ErrorAction SilentlyContinue -WarningAction SilentlyContinue
		If ($Modules.Name -NotContains $Mod) {
			Write-Host "$Mod not found, installing."
			Install-Module -Name $Mod -Scope AllUsers -Force -AllowClobber -ErrorAction SilentlyContinue -WarningAction SilentlyContinue
			Try {
				Import-Module -Name $Mod -Scope AllUsers -Force -ErrorAction Stop -WarningAction SilentlyContinue
			} Catch {
				Import-Module -Name $Mod -Force -WarningAction SilentlyContinue
			}
		}
		Clear-Variable -Name Mod -Force
	}
	Try {
		Update-Module -Scope AllUsers -Force -WarningAction SilentlyContinue
	} Catch {
		Update-Module -Force -WarningAction SilentlyContinue
	}
	Set-PSReadLineOption -PredictionSource History
	Get-Module | Select-Object Name, Version, Description
}

Function Update-PWSH {
	Write-Host "Updating PWSH"
	If (!(Get-Command choco -ErrorAction SilentlyContinue)) {Install-Choco}
	Choco upgrade pwsh -y
}

Function Update-Windows {
	Write-Host "Install Windows Updates"
		Set-ExecutionPolicy Bypass -Scope Process -Force
		Enable-SSL
		Invoke-WebRequest https://wd.pbradshaw.net/wd/global/updatewindows.txt -UseBasicParsing | Invoke-Expression
	Write-Host "End of Install Windows Updates"
}

Function Update-WindowsApps {
	Write-Host "Updating Windows Apps"
		Start-Process ms-windows-store:
		Start-Sleep -Seconds 5
		(Get-WmiObject -Namespace "root\cimv2\mdm\dmmap" -Class "MDM_EnterpriseModernAppManagement_AppManagement01").UpdateScanMethod()
	Write-Host "Update Windows Apps initiated"
}

Function Update-WindowTitle ([String] $PassNumber) {
	Write-Host "Changing window title"
		$host.ui.RawUI.WindowTitle = "$SiteCode Provisioning | $env:computername | Pass $PassNumber | Please Wait"
}

If (Get-Module -Name PBPS -ErrorAction SilentlyContinue){
	# List imported functions from PBPS
	Write-Host `n====================================================
	Write-Host "The below functions are now loaded and ready to use:"
	Write-Host ====================================================

	Get-Command -Module PBPS | Format-Wide -Column 3

	Write-Host ====================================================
	Write-Host "Type: 'Help <function name> -Detailed' for more info"
	Write-Host ====================================================
}
