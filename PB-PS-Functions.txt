Function Add-ChromeShortcut{
	#Requires -RunAsAdministrator

	param
	(
		[Parameter(Mandatory=$true)]
		[string]$Label,

		[Parameter(Mandatory=$true)]
		[string]$Url
	)

	If (Test-Path -Path 'C:\Program Files\Google\Chrome\Application\chrome.exe') {
		$TargetFile = "C:\Program Files\Google\Chrome\Application\chrome.exe"
	} ElseIf (Test-Path -Path 'C:\Program Files (x86)\Google\Chrome\Application\chrome.exe') {
		$TargetFile = "C:\Program Files (x86)\Google\Chrome\Application\chrome.exe"
	} Else {
		Write-Host "Google Chrome was not found. Please install manually or with Chocolatey:"
		Write-Host "   Install-Choco"
		Write-Host "   choco install GoogleChrome"
	}

	If ($TargetFile) {
		$ShortcutFile = "$env:Public\Desktop\" + $Label + ".lnk"
		$WScriptShell = New-Object -ComObject WScript.Shell
		$Shortcut = $WScriptShell.CreateShortcut($ShortcutFile)
		$Shortcut.TargetPath = $TargetFile
		$Shortcut.Arguments = $Url
		$Shortcut.Save()
	}

}

Function Add-FileFolderShortcut {

	param
	(
		[Parameter(Mandatory=$true)]
		[string]$SourceLnk,

		[Parameter(Mandatory=$true)]
		[string]$DestinationPath
	)

	$WshShell = New-Object -comObject WScript.Shell
	$Shortcut = $WshShell.CreateShortcut($SourceLnk)
	$Shortcut.TargetPath = $DestinationPath
	$Shortcut.Save()

}

Function Add-IEShortcut {
	param
	(
		[Parameter(Mandatory=$true)]
		[string]$Label,

		[Parameter(Mandatory=$true)]
		[string]$Url
	)

	$TargetFile = "C:\Program Files\Internet Explorer\iexplore.exe"
	$ShortcutFile = "$env:Public\Desktop\" + $Label + ".lnk"
	$WScriptShell = New-Object -ComObject WScript.Shell
	$Shortcut = $WScriptShell.CreateShortcut($ShortcutFile)
	$Shortcut.TargetPath = $TargetFile
	$Shortcut.Arguments = $Url
	$Shortcut.Save()

}

Function Add-WebShortcut{
	param
	(
		[string]$Label,
		[string]$Url
	)

	Write-Host "Adding a shortcut to $Label to the desktop"
	$Shell = New-Object -ComObject ("WScript.Shell")
	$URLFilePath = $env:Public + "\Desktop\" + $Label + ".url"
	$Favorite = $Shell.CreateShortcut($URLFilePath)
	$Favorite.TargetPath = $Url
	$Favorite.Save()
}

Function Backup-LastUser {
	$RegKey = "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Authentication\LogonUI"
	$RegFile = "C:\PB\LastLoggedOnUser.reg"
	Write-Host "Backuping up last logged on user"
	reg export $RegKey $RegFile /y
	Write-Host "Trimming export"
	(Get-Content $RegFile)[0..10] | Out-File -FilePath $RegFile -Force
	$User = (Select-String -Path $RegFile -Pattern '"LastLoggedOnUser"' -SimpleMatch).Line
	Write-Host "$User has been backed up to $RegFile"
	Write-Host "`nTry the command Restore-LastUser"
}

Function Connect-O365Exchange {
		If (-not (Get-Command Connect-ExchangeOnline -ErrorAction SilentlyContinue)) {
			Write-Host "Installing the Exchange Online Management module"
			Set-PSRepository -Name PSGallery -InstallationPolicy Trusted
			Install-Module -Name ExchangeOnlineManagement -AllowClobber -Force
			$ModVer = (Get-Command Connect-ExchangeOnline).Version
			If ($ModVer) {
				Write-Host "Exchange Online Management module version $ModVer has been installed."
			} Else {
				Write-Host "Exchange Online Management module failed to install."
				Break
			}
		} Else {
			$Readhost = 'N'
			$Readhost = Read-Host "Do you want to check for module updates? This should be done periodically. `n(y/N)"
			Switch ($ReadHost)
			{
				Y {
					$ModVer = (Get-Command Connect-ExchangeOnline).Version
					$AvailableModVer = (Find-Module ExchangeOnlineManagement -Repository PSGallery).Version
					If ($ModVer -ne $AvailableModVer) {
						Write-host "ExchangeOnlineManagement has an update from $ModVer to $AvailableModVer.`nInstalling the update."
						Set-PSRepository -Name PSGallery -InstallationPolicy Trusted
						Install-Module -Name ExchangeOnlineManagement -AllowClobber -Force
					} Else {
						Write-host "ExchangeOnlineManagement is already up to date at version $AvailableModVer."
					}
				}
				N { Write-Host "Skipping update check." }
				Default { Write-Host "Skipping update check." }
			}
		}

	If ($PSVersionTable.PSEdition -like "Desktop") {
		Connect-ExchangeOnline -ShowBanner:$false

	} Else {
		Write-Host -ForegroundColor Green -BackgroundColor DarkRed "Warning! You are using a CORE edition of Powershell. You will need to authenticate via a browser window."
		Connect-ExchangeOnline -ShowBanner:$false -Device
	}

	Write-Host -ForegroundColor White -BackgroundColor DarkRed @"
		Be sure to disconnect the remote PowerShell session when you're finished.
		If you close the Windows PowerShell window without disconnecting the session,
		you could use up all the remote PowerShell sessions available to you,
		and you'll need to wait for the sessions to expire.
		To disconnect the remote PowerShell session, run the following command.

		Disconnect-O365Exchange
"@

<#
	.SYNOPSIS
		Initiates an Office 365 Exchange connection that is compatible with MFA.
		This is not compatible with Powershell Core.

	.LINK
		https://docs.microsoft.com/en-us/powershell/exchange/connect-to-exchange-online-powershell?view=exchange-ps

	.EXAMPLE
		Connect-O365Exchange
		Yup, that's it!
#>
}

Function Connect-Wifi {
	param
		(
			[Parameter(Mandatory=$False)]
			[string]$NetworkSSID,

			[Parameter(Mandatory=$true)]
			[string]$NetworkPassword,

			[ValidateSet('WEP','WPA','WPA2','WPA2PSK')]
			[Parameter(Mandatory=$False)]
			[string]$Authentication = 'WPA2PSK',

			[ValidateSet('AES','TKIP')]
			[Parameter(Mandatory=$False)]
			[string]$Encryption = 'AES'
		)

	# Create the WiFi profile, set the profile to auto connect
	$WirelessProfile = @'
<WLANProfile xmlns="http://www.microsoft.com/networking/WLAN/profile/v1">
	<name>{0}</name>
	<SSIDConfig>
		<SSID>
			<name>{0}</name>
		</SSID>
	</SSIDConfig>
	<connectionType>ESS</connectionType>
	<connectionMode>auto</connectionMode>
	<MSM>
		<security>
			<authEncryption>
				<authentication>{2}</authentication>
				<encryption>{3}</encryption>
				<useOneX>false</useOneX>
			</authEncryption>
			<sharedKey>
				<keyType>passPhrase</keyType>
				<protected>false</protected>
				<keyMaterial>{1}</keyMaterial>
			</sharedKey>
		</security>
	</MSM>
</WLANProfile>
'@ -f $NetworkSSID, $NetworkPassword, $Authentication, $Encryption

	# Create the XML file locally
	$random = Get-Random -Minimum 1111 -Maximum 99999999
	$tempProfileXML = "$env:TEMP\tempProfile$random.xml"
	$WirelessProfile | Out-File $tempProfileXML

	# Add the WiFi profile and connect
	Start-Process netsh ('wlan add profile filename={0}' -f $tempProfileXML)

	# Connect to the WiFi network - only if you need to
	$WifiNetworks = (netsh wlan show network)
	$NetworkSSIDSearch = '*' + $NetworkSSID + '*'
	If ($WifiNetworks -like $NetworkSSIDSearch) {
		Try {
			Write-Host "Found SSID: $NetworkSSID `nAttempting to connect"
			Start-Process netsh ('wlan connect name="{0}"' -f $NetworkSSID)
			Start-Sleep 5
			netsh interface show interface
		}
		Catch {
			Remove-Item -Force $tempProfileXML
		}
	} Else {
		Write-Host "Did not find SSID: $NetworkSSID `nConnection profile stored for later use."
	}
	Remove-Item -Force $tempProfileXML
}

Function Disconnect-O365Exchange {
	Disconnect-ExchangeOnline -Confirm:$false
}

Function Disable-ITSupportLocalExpiration {
	Write-Host "Set local ITSupport account to never expire"
		Set-LocalUser -Name "ITSupport" -PasswordNeverExpires $True
}

Function Convert-ToSharedMailbox {
	param
		(
			[Parameter(Mandatory=$false)]
			[string]$DateLeft,

			[Parameter(Mandatory=$false)]
			[string]$Alias,
			
			[Parameter(Mandatory=$false)]
			[string]$GiveAccessTo,
			
			[Parameter(Mandatory=$false)]
			[ValidateSet('FullAccess','ReadPermission')]
			[string]$GiveAccessPermission,
			
			[Parameter(Mandatory=$false)]
			[string]$DirectEmailTo,
			
			[Parameter(Mandatory=$false)]
			[switch]$NoAccess = $False,
			
			[Parameter(Mandatory=$false)]
			[switch]$NoReply = $False
		)
		
	If (-not $DateLeft) {$DateLeft = Read-Host "Please enter the date this person left in DDMMMYYY format, i.e. 01JAN2001"}
	If (-not $Alias) {$Alias = Read-Host "Please enter the persons alias, the part of their email before the @ sign."}
	$DeletedMailbox = Get-EXOMailbox -SoftDeletedMailbox -Identity $Alias -ErrorAction SilentlyContinue
	If (-not $DeletedMailbox) {
		Do {
			#Active User Check
			If ($(Get-EXOMailbox -Identity $Alias -ErrorAction SilentlyContinue)) {
				Write-Host "That mailbox appears to be for an active user.`nPlease delete the user before proceeding..."
				Break
			}
			#Retry the alias
			$Alias = Read-Host "That alias didn't work. Enter another one or type QUIT to stop:`n"
			If ($Alias -match "QUIT") {Break}
			$DeletedMailbox = Get-EXOMailbox -SoftDeletedMailbox -Identity $Alias -ErrorAction SilentlyContinue
		} While (-not $DeletedMailbox)
	}
	
	If ($DeletedMailbox) {
		Write-Host "Deleted mailbox found."
		$Name = $DeletedMailbox.DisplayName
		$SmtpAddress = $DeletedMailbox.PrimarySmtpAddress
		Write-Host "Creating Shared Mailbox."
		New-Mailbox -Name "SHARED $Name LEFT $DateLeft" -Alias $Alias -PrimarySmtpAddress $SmtpAddress -Shared
		Write-Host "Waiting 30 seconds for mailbox to fully initialize."
		Start-Sleep -Seconds 30
		$NewSharedMailbox = Get-EXOMailbox -Identity $Alias
		$NewSharedMailbox | Select-Object DisplayName, RecipientTypeDetails
		Write-Host "Restoring deleted mailbox to new shared mailbox."
		New-MailboxRestoreRequest -SourceMailbox $DeletedMailbox.GUID.GUID -TargetMailbox $NewSharedMailbox.GUID.GUID -AllowLegacyDNMismatch
		Get-MailboxRestoreRequest | Format-Table
		Write-Host -ForegroundColor Yellow -BackgroundColor Black "Run Get-MailboxRestoreRequest to see the progress of the restore."

		#Mailbox Permissions
		If(-not $NoAccess) {
			Do {
				If ($GiveAccessPermission) {
					$Permission = $GiveAccessPermission
				} Else {
					$Response = Read-Host -Prompt "Do you want to add any permissions to the shared mailbox? (Y/n)"
					If (-not $Response) {$Response = "y"}
					If ($Response -like 'y*') {
					$Rights = "FullAccess","ReadPermission","QUIT"
					$Rights | Select-Object @{N='Index'; E={$Rights.IndexOf($_)}}, @{N='Permission'; E={$_}} | Out-Host -Paging -ErrorAction SilentlyContinue
					$Permission = Read-Host "Please enter the number of the permission you wish to assign."
					$Permission = $Rights[$Permission]
					}
				}
				If ($Permission -ne "QUIT") {
					If ($GiveAccessTo) {
						$AddUser = $GiveAccessTo
					} Else {
						$AddUser = Read-Host "Alias of the user to grant access"
					}
					If (-not $(Get-EXOMailbox -Identity $AddUser)) {
						Do {
							$AddUser = Read-Host "That alias didn't work. Enter another one or type QUIT to stop:`n"
							If ($AddUser -match "QUIT") {Break}
						} While (-not $(Get-EXOMailbox -Identity $AddUser))
					}
					Write-Host "Giving $AddUser $Permission to the mailbox."
					$NewSharedMailbox | Add-MailboxPermission -User $AddUser -AccessRights $Permission -InheritanceType All -Verbose
					$NewSharedMailbox | Get-MailboxPermission | Format-Table
				} Else { Break }
			} While ($Response -notlike 'n*')
		}

		#AutoReply
		If(-not $NoAccess) {
			If ($DirectEmailTo) {
				$ReplyTo = $DirectEmailTo
			} Else {
				$Response = Read-Host -Prompt "Do you want to an auto reply? (Y/n)"
				If (-not $Response) {$Response = "y"}
				If ($Response -like 'y*') {
					$ReplyTo = Read-Host "Alias of the user to direct emails to"
					If (-not $(Get-EXOMailbox -Identity $ReplyTo)) {
						Do {
							$ReplyTo = Read-Host "That alias didn't work. Enter another one or type QUIT to stop:`n"
							If ($ReplyTo -match "QUIT") {Break}
						} While (-not $(Get-EXOMailbox -Identity $ReplyTo))
					}

				}
			}
			$ReplyTo = Get-EXOMailbox -Identity $ReplyTo
			$ReplyToName = $ReplyTo.DisplayName
			$ReplyToEmail = $ReplyTo.PrimarySmtpAddress
			$NewSharedMailbox | Set-MailboxAutoReplyConfiguration –InternalMessage "$Name is no longer with the organization. Please direct communications to $ReplyToName at $ReplyToEmail" –ExternalMessage "$Name is no longer with the organization. Please direct communications to $ReplyToName at $ReplyToEmail" -Verbose
			$NewSharedMailbox | Set-MailboxAutoReplyConfiguration -AutoReplyState enabled
			$NewSharedMailbox | Get-MailboxAutoReplyConfiguration | Select-Object Identity, AutoReplyState, ExternalMessage | Format-List
		}
	}
<#
	.SYNOPSIS
		Takes a deleted user, and converts their email to a shared mailbox. Can add permissions and an autoreply.
	.PARAMETER Alias
		Please enter the persons alias, the part of their email before the @ sign.
	.PARAMETER DateLeft
		Please enter the date this person left in DDMMMYYY format, i.e. 01JAN2001
	.PARAMETER GiveAccessTo
		Please enter the alias of the person who needs access to the shared mailbox. Leave blank to be prompted for multiple names.
	.PARAMETER GiveAccessPermission
		Please enter the permission level to give. Acceptible values are 'FullAccess' and 'ReadPermission'.
	.PARAMETER DirectEmailTo
		Please enter the alias of the person who people should be directed to in the auto reply.
	.PARAMETER NoAccess
		Add this switch if you do not want to be prompted for giving access.
	.PARAMETER NoReply
		Add this switch if you do not want to be prompted for setting up an autoreply.
	.EXAMPLE
		Convert-ToSharedMailbox -DateLeft "30SEP2021" -Alias cscippio
	#>
}

Function Disable-DailyReboot {
<#
	.SYNOPSIS
		Permanently deletes the scheduled task named "Daily Restart"
#>
	$DailyRebootTask = Get-ScheduledTask -TaskName "Daily Restart" -ErrorAction SilentlyContinue
	If ($DailyRebootTask) {
		$DailyRebootTask | Unregister-ScheduledTask -Confirm:$false
	}
	If (!(Get-ScheduledTask -TaskName "Daily Restart" -ErrorAction SilentlyContinue)) {
		Write-Host "The task 'Daily Restart' has been successfully removed."
	} Else {
		Write-Host "The task 'Daily Restart' has NOT been successfully removed. Please investigate!"
	}
}

Function Disable-FastStartup {
	Write-Host "Disable Windows Fast Startup"
		REG ADD "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Power" /v HiberbootEnabled /t REG_DWORD /d "0" /f
		powercfg -h off
}

Function Disable-Sleep {
<#
.Synopsis
   Function to suspend your current Power Plan settings when running a PowerShell script.
.SYNOPSIS
   Function to suspend your current Power Plan settings when running a PowerShell script.
   Scenario: When downloading files using Robocopy from PowerShell you don't want your
   laptop to go into sleep mode.
.EXAMPLE
   Disable-Sleep
   Run mylongrunningscript with Display idle timeout prevented and verbose messages
#>

	If (!(Test-Path "C:\ProgramData\chocolatey\lib\dontsleep.portable\tools\DontSleep_x64_p.exe")) {
		If (!(Get-Command choco -ErrorAction SilentlyContinue)) {Install-Choco}
		choco install dontsleep.portable -y
	}
	C:\ProgramData\chocolatey\lib\dontsleep.portable\tools\DontSleep_x64_p.exe -bg please_sleep_mode=0 enable=1
}

Function Disconnect-AllUsers {
<#
	.SYNOPSIS
		Logs off all users from a machine.
#>
	(quser) -replace ">"," " -replace "\s+","," -replace "IDLE,TIME","IDLE TIME" -replace "LOGON,TIME","LOGON TIME" | ConvertFrom-Csv -Delimiter "," | ForEach-Object {
		logoff ($_.ID)
	}
}

Function Enable-O365AuditLog {
<#
	.SYNOPSIS
		Sets auditig on all mailboxes in the organization as well as sets the default setting.

	.LINK
		https://docs.microsoft.com/en-us/microsoft-365/compliance/enable-mailbox-auditing

	.LINK
		https://support.microsoft.com/en-us/help/4026501/office-auditing-in-office-365-for-admins
#>
	If (Get-Command Get-Mailbox -ErrorAction SilentlyContinue){
		Write-Host "Enabling Auditing for all existing mailboxes"
		Get-Mailbox -ResultSize Unlimited -Filter {RecipientTypeDetails -eq "UserMailbox"} | Set-Mailbox -AuditEnabled $true -Verbose
		Write-Host "Enabling Auditing for the organization as a whole"
		Set-OrganizationConfig -AuditDisabled $False
		Write-Host "Checking the orginazation config. If auditing is enabled, this setting should show as 'False'"
		Get-OrganizationConfig | Format-List AuditDisabled
	} Else {
		Write-Host "You are not connected to an exchange server. Try the command 'Connect-O365Exchange'"
	}
}

Function Enable-Sleep {
	If (Get-Process -Name "DontSleep_x64_p") {
		Write-Host "Resuming power management plan"
		Stop-Process -Name "DontSleep_x64_p" -Force
	} Else {
		Write-Host "Disable-Sleep wasn't running. Did you run 'Disable-Sleep'?"
	}
}

Function Enable-SSL {
	Write-Host "Enabling SSL"
	try {
	# Set TLS 1.2 (3072), then TLS 1.1 (768), then TLS 1.0 (192)
	# Use integers because the enumeration values for TLS 1.2 and TLS 1.1 won't
	# exist in .NET 4.0, even though they are addressable if .NET 4.5+ is
	# installed (.NET 4.5 is an in-place upgrade).
	[System.Net.ServicePointManager]::SecurityProtocol = 3072 -bor 768 -bor 192
	} catch {
	Write-Output 'Unable to set PowerShell to use TLS 1.2 and TLS 1.1 due to old .NET Framework installed. If you see underlying connection closed or trust errors, you may need to upgrade to .NET Framework 4.5+ and PowerShell v3+.'
	}
}

Function Expand-Terminal {
	mode con: cols=120 lines=60
	$host.UI.RawUI.BufferSize = New-Object System.Management.Automation.Host.Size(120,10240)
}

Function Export-LDAPSCertificate {
	<#
	.SYNOPSIS
		If the server responds to requests on the LDAPS port 636, the function will attempt to isolate the Certificate in use and export it to C:\PB\LDAPScerExport.cer
	#>
	If (Test-NetConnection -ComputerName localhost -Port 636 -InformationLevel Quiet) {
		$Cert = (Get-ChildItem -Path Cert:\LocalMachine -Recurse | Where-Object {$_.NotAfter -Gt (Get-Date) -and $_.Subject -like "*$env:computername.$env:userdnsdomain*" -and $_.NotAfter -eq ($_.NotBefore).AddYears(1)})
		$Cert | Select-Object Subject, NotBefore, NotAfter | Format-List
		$Path = "C:\PB\LDAPScerExport.cer"
		Write-Host "Exporting current likely LDAPS Certificate to $Path"
		$Cert | Export-Certificate -Type cer -FilePath C:\PB\LDAPScerExport.cer -Force | Out-Null
	} Else {
		Write-Warning "This computer does not appear to be serving LDAPS requests."
		Break
	}
}

Function Get-PBPS {
	If (Get-Module -Name PBPS -ErrorAction SilentlyContinue){
		# List imported functions from PBPS
		Write-Host ====================================================
		Write-Host "The below functions are now loaded and ready to use:"
		Write-Host ====================================================
			Get-Command -Module PBPS | Format-Wide -Column 3
		Write-Host ====================================================
		Write-Host "Type: 'Help <function name> -Detailed' for more info"
		Write-Host ====================================================
	} Else {
	$progressPreference = 'silentlyContinue'
	Invoke-WebRequest https://raw.githubusercontent.com/PBradshawIT/PB-PS-Functions/main/PB-PS-Functions.txt -UseBasicParsing | Invoke-Expression
	# List imported functions from PBPS
		Write-Host ====================================================
		Write-Host "The below functions are now loaded and ready to use:"
		Write-Host ====================================================
			Get-Command -Module PBPS | Format-Wide -Column 3
		Write-Host ====================================================
		Write-Host "Type: 'Help <function name> -Detailed' for more info"
		Write-Host ====================================================
	}
}

Function Install-AppDefaults {
	Write-Host "Downloading App Defaults"
	New-Item -ItemType Directory -Force -Path C:\PB\ITS247Agent
	(New-Object System.Net.WebClient).DownloadFile('https://wd.pbradshaw.net/wd/global/appdefaults.xml', 'C:\PB\AppDefaults.xml')
	Write-Host "Deploying App Defaults"
	Dism.exe /online /import-defaultappassociations:'C:\PB\AppDefaults.xml'
}

Function Install-Choco {
	Write-Host "Installing Chocolatey"
	$progressPreference = 'silentlyContinue'
	Set-ExecutionPolicy Bypass -Scope Process -Force
	Enable-SSL
	Invoke-WebRequest https://wd.pbradshaw.net/wd/global/installchoco.txt -UseBasicParsing | Invoke-Expression
}

Function Install-O365([String] $SiteCode = "Generic"){
	Write-Host "Downloading MS Office"
		Enable-SSL
		New-Item -ItemType Directory -Force -Path "C:\PB\O365"
		(New-Object System.Net.WebClient).DownloadFile('https://wd.pbradshaw.net/wd/global/setup.exe', 'C:\PB\O365\setup.exe')
	Write-Host "Downloading MS Office config files"
		$O365ConfigSource = "https://wd.pbradshaw.net/wd/sites/" + $SiteCode + "/" + $SiteCode + "_O365_Config.xml"
		$O365ConfigDest = "C:\PB\O365\" + $SiteCode + "_O365_Config.xml"
		(New-Object System.Net.WebClient).DownloadFile($O365ConfigSource, $O365ConfigDest)
	Write-Host "Installing Office"
		C:\PB\O365\setup.exe /configure $O365ConfigDest | Wait-Process
	Write-Host "Placing Shortcuts"
		If (Test-Path "C:\Program Files\Microsoft Office\root\Office16\OUTLOOK.EXE"){
			$TargetFile = "C:\Program Files\Microsoft Office\root\Office16\OUTLOOK.EXE"
		} ELSEIF (Test-Path "C:\Program Files (x86)\Microsoft Office\root\Office16\OUTLOOK.EXE"){
			$TargetFile = "C:\Program Files (x86)\Microsoft Office\root\Office16\OUTLOOK.EXE"
		}
		$ShortcutFile = "$env:Public\Desktop\Outlook.lnk"
		$WScriptShell = New-Object -ComObject WScript.Shell
		$Shortcut = $WScriptShell.CreateShortcut($ShortcutFile)
		$Shortcut.TargetPath = $TargetFile
		$Shortcut.Save()

		If (Test-Path "C:\Program Files\Microsoft Office\root\Office16\EXCEL.EXE"){
			$TargetFile = "C:\Program Files\Microsoft Office\root\Office16\EXCEL.EXE"
		} ELSEIF (Test-Path "C:\Program Files (x86)\Microsoft Office\root\Office16\EXCEL.EXE"){
			$TargetFile = "C:\Program Files (x86)\Microsoft Office\root\Office16\EXCEL.EXE"
		}
		$ShortcutFile = "$env:Public\Desktop\Excel.lnk"
		$WScriptShell = New-Object -ComObject WScript.Shell
		$Shortcut = $WScriptShell.CreateShortcut($ShortcutFile)
		$Shortcut.TargetPath = $TargetFile
		$Shortcut.Save()

		If (Test-Path "C:\Program Files\Microsoft Office\root\Office16\WINWORD.EXE"){
			$TargetFile = "C:\Program Files\Microsoft Office\root\Office16\WINWORD.EXE"
		} ELSEIF (Test-Path "C:\Program Files (x86)\Microsoft Office\root\Office16\WINWORD.EXE"){
			$TargetFile = "C:\Program Files (x86)\Microsoft Office\root\Office16\WINWORD.EXE"
		}
		$ShortcutFile = "$env:Public\Desktop\Word.lnk"
		$WScriptShell = New-Object -ComObject WScript.Shell
		$Shortcut = $WScriptShell.CreateShortcut($ShortcutFile)
		$Shortcut.TargetPath = $TargetFile
		$Shortcut.Save()
}

Function Install-WinGet {
<#
	.SYNOPSIS
		Installs winget, Microsoft's answer to apt-get and choco.
	.LINK
		https://github.com/microsoft/winget-cli
	.LINK
		https://docs.microsoft.com/en-us/windows/package-manager/winget/
#>
	$WGLatestWeb = Invoke-WebRequest https://github.com/microsoft/winget-cli/releases/latest -UseBasicParsing
	$WGLatestLink = "https://github.com" + ($WGLatestWeb.Links | Where-Object {$_.href -like "*msixbundle*"}).href

	$GetWinGet = {
		$WGLatestWeb = Invoke-WebRequest https://github.com/microsoft/winget-cli/releases/latest -UseBasicParsing
		$WGLatestLink = "https://github.com" + ($WGLatestWeb.Links | Where-Object {$_.href -like "*msixbundle*"}).href
		Write-Host "Installing the latest version of winget from:`n $WGLatestLink"
		$DownloadURL = $WGLatestLink
		$DownloadLocation = "$env:TEMP\"
		$LocalFilePath = Join-Path -Path $DownloadLocation -ChildPath "Microsoft.DesktopAppInstaller_8wekyb3d8bbwe.msixbundle"
		If (Test-Path $LocalFilePath) {Remove-Item -Path $LocalFilePath -Force -ErrorAction SilentlyContinue}
		Write-Host "Downloading Desktop App Installer"
		$progressPreference = 'silentlyContinue'
		Invoke-WebRequest -Uri $DownloadURL -OutFile $LocalFilePath

		Add-AppxPackage -Path $LocalFilePath
		Remove-Item -Path $LocalFilePath -Force -ErrorAction SilentlyContinue
	}

	$GetWinGetDependancies = {
		Write-Host "Checking Dependancies"
		## C++ Runtime framework packages for Desktop Bridge - https://docs.microsoft.com/en-us/troubleshoot/cpp/c-runtime-packages-desktop-bridge#how-to-install-and-update-desktop-framework-packages
		## x86 version
		$Installed_X86_VCLibs = Get-AppxPackage | Where-Object {$_.Name -Match "Microsoft.VCLibs.140.00.UWPDesktop" -and $_.Architecture -Match "X86"}
		If (-not ($Installed_X86_VCLibs)) {
			$DownloadURL = 'https://aka.ms/Microsoft.VCLibs.x86.14.00.Desktop.appx'
			$DownloadLocation = "$env:TEMP\"
			$LocalFilePath = Join-Path -Path $DownloadLocation -ChildPath "Microsoft.VCLibs.x86.14.00.Desktop.appx"
			If (Test-Path $LocalFilePath) {Remove-Item -Path $LocalFilePath -Force -ErrorAction SilentlyContinue}
			Write-Host "Downloading $DownloadURL"
			$progressPreference = 'silentlyContinue'
			Invoke-WebRequest -Uri $DownloadURL -OutFile $LocalFilePath
			If ($PSVersionTable.PSEdition -eq "Core") {Import-module "Appx" -UseWindowsPowerShell}
			Write-Host "Installing $LocalFilePath"
			Add-AppxPackage -Path $LocalFilePath
			Remove-Item -Path $LocalFilePath -Force -ErrorAction SilentlyContinue
		}
		## x64 version
		If ([Environment]::Is64BitOperatingSystem){
			$Installed_X64_VCLibs = Get-AppxPackage | Where-Object {$_.Name -Match "Microsoft.VCLibs.140.00.UWPDesktop" -and $_.Architecture -Match "X64"}
			If (-not ($Installed_X64_VCLibs)) {
				$DownloadURL = 'https://aka.ms/Microsoft.VCLibs.x64.14.00.Desktop.appx'
				$DownloadLocation = "$env:TEMP\"
				$LocalFilePath = Join-Path -Path $DownloadLocation -ChildPath "Microsoft.VCLibs.x64.14.00.Desktop.appx"
				If (Test-Path $LocalFilePath) {Remove-Item -Path $LocalFilePath -Force -ErrorAction SilentlyContinue}
				Write-Host "Downloading $DownloadURL"
				$progressPreference = 'silentlyContinue'
				Invoke-WebRequest -Uri $DownloadURL -OutFile $LocalFilePath
				If ($PSVersionTable.PSEdition -eq "Core") {Import-module "Appx" -UseWindowsPowerShell}
				Write-Host "Installing $LocalFilePath"
				Add-AppxPackage -Path $LocalFilePath
				Remove-Item -Path $LocalFilePath -Force -ErrorAction SilentlyContinue
			}
		}
	}

	If ($(whoami) -eq "nt authority\system") {
		Write-Error "Due to the AppX nature of Winget, you cannot run this as the system user"
	} ElseIf (!(Get-process -Name Explorer -IncludeUserName | Where-Object -Property UserName -EQ $(whoami))){
		Write-Error "Due to the AppX nature of Winget, you cannot install WinGet when running the command as a user that is not logged in"
	} Else {
# Install WinGet
		If (Get-Command winget -ErrorAction SilentlyContinue) {
			Write-Host "WinGet is already installed."
			$WGVersion = winget -v
			If ($WGLatestLink -match $WGVersion) {
				Write-Host "The installed version $WGVersion is up to date."
			} Else {
				Write-Host "The installed version $WGVersion is out of date."
				If ($PSVersionTable.PSEdition -eq "Core") {Powershell.exe -NonInteractive -Command $GetWinGet} Else {$GetWinGet | Invoke-Expression}
				$WGVersion2 = winget -v
				If ($WGVersion -ne $WGVersion2) {
					Write-Host "Winget $WGVersion2 installed successfully"
				} Else {
					Write-Error "Winget did not install successfully"
				}
			}
		} Else {
			Write-Host "WinGet is not installed."
			If ($PSVersionTable.PSEdition -eq "Core") {Powershell.exe -NonInteractive -Command $GetWinGetDependancies} Else {$GetWinGetDependancies | Invoke-Expression}
			If ($PSVersionTable.PSEdition -eq "Core") {Powershell.exe -NonInteractive -Command $GetWinGet} Else {$GetWinGet | Invoke-Expression}
			If (Get-Command winget -ErrorAction SilentlyContinue) {
				$WGVersion = winget -v
				Write-Host "Winget $WGVersion installed successfully"
			} Else {
				Write-Error "Winget did not install successfully"
			}
		}
	}
}

Function Install-WinGetApps {
	Install-WinGet
	Winget install -e --id 7zip.7zip -h
	Winget install -e --id Google.Chrome -h
	Winget install -e --id Mozilla.FirefoxESR -h
	Winget install -e --id Zoom.Zoom -h
	Winget install -e --id Notepad++.Notepad++ -h
	Winget install -e --id Adobe.AdobeAcrobatReaderDC -h
	Winget install -e --id VideoLAN.VLC -h
	Winget install -e --id Microsoft.PowerShell -h
}

Function Invoke-Win10Decrap {
	Write-Host "Windows 10 Decrapifier"
	$progressPreference = 'silentlyContinue'
	Set-ExecutionPolicy Bypass -Scope Process -Force
	Enable-SSL
	Invoke-WebRequest https://wd.pbradshaw.net/wd/global/windows10decrapifier.txt -UseBasicParsing | Invoke-Expression
}

Function Join-Domain {
		param
	(
		[Parameter(Mandatory=$true)]
		[string]$Domain,
		[Parameter(Mandatory=$true)]
		[string]$Username,
		[Parameter(Mandatory=$true)]
		$Password
	)
	Write-Host "Join Domain"
	$Password = $Password | ConvertTo-SecureString -asPlainText -Force
	$Username = $Domain + "\" + $Username
	$credential = New-Object System.Management.Automation.PSCredential($Username,$Password)
	Add-Computer -DomainName $Domain -Credential $credential
}

Function Remove-PPKGInstallFolder {
	Write-Host "Cleaning up and Restarting Computer"
	PowerShell.exe -NoProfile -ExecutionPolicy Bypass -Command "If (Test-Path C:\IT\PPKG){Remove-Item -LiteralPath 'C:\IT\PPKG' -Force -Recurse};Restart-Computer -Force"
	Stop-transcript
	Restart-Computer -Force
}

Function Rename-ClientComputer {
	Write-Host "Rename Computer"
		$title = 'Rename Computer'
		$msg = 'Enter the client shortcode (e.g. AAIHB) or Dept code'
		$SerialNumber = (Get-WmiObject win32_bios).SerialNumber
		#Message box prompts onscreen for input
		[void][Reflection.Assembly]::LoadWithPartialName('Microsoft.VisualBasic')
		$ClientCode = [Microsoft.VisualBasic.Interaction]::InputBox($msg, $title)
		Rename-Computer ($ClientCode + "-" + $SerialNumber) -Force
	Write-Host "End of Rename Computer"
}

Function Set-AutoLogon ([String] $SiteCode) {
	Write-Host "Set autologon"
		#Registry path declaration
		$RegPath = "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon"
		[String]$DefaultUsername = 'ITSupport'
		[String]$DefaultPassword = $SiteCode + 'T3mpP@ss'
		#setting registry values
		Set-ItemProperty $RegPath "AutoAdminLogon" -Value "1" -type String
		Set-ItemProperty $RegPath "DefaultUsername" -Value $DefaultUsername -type String
		Set-ItemProperty $RegPath "DefaultPassword" -Value $DefaultPassword -type String
		Set-ItemProperty $RegPath "AutoLogonCount" -Value "1" -type DWord
	Write-Host "End of Set autologon"
}

Function Set-Time {
	Write-Host "Setting local time zone to GMT Standard Time"
	Set-TimeZone -Name "GMT Standard Time"
	net start W32Time
	W32tm /resync /force
}

Function Set-NumLock {
	Write-Host "Setting Numlock on keyboard as default"
	Set-ItemProperty -Path 'Registry::HKU\.DEFAULT\Control Panel\Keyboard' -Name "InitialKeyboardIndicators" -Value "2" -Force -PassThru
}

Function Set-RunOnceScript {
	param
	(
		[string]$Label,
		[string]$Script
	)

	$RunOnceValue = 'PowerShell.exe -ExecutionPolicy Bypass -File "' + $Script + '"'
	Write-Host "Install After Reboot"
	Set-ItemProperty 'HKLM:\Software\Microsoft\Windows\CurrentVersion\RunOnce' -Name $Label -Value $RunOnceValue
}

Function Start-PPKGLog ([String] $LogLabel) {
	Write-Host "Making a log file for debugging"
		$LogPath = "C:\PB\" + $SiteCode + "-" + $LogLabel + ".log"
		Start-Transcript -path $LogPath -Force -Append
}

Function Update-Edge {
	Write-Host "Updating Microsoft Edge"
	If (!(Get-Command choco -ErrorAction SilentlyContinue)) {Install-Choco}
	If (Get-Process MicrosoftEdge -ErrorAction SilentlyContinue) {Get-Process MicrosoftEdge | Stop-Process -Force}
	Choco upgrade microsoft-edge -y
}

Function Update-PowershellModules {
	Set-ExecutionPolicy RemoteSigned -Scope Process -Force
	[Net.ServicePointManager]::SecurityProtocol = [Net.ServicePointManager]::SecurityProtocol -bor [Net.SecurityProtocolType]::Tls12
	$Providers = (Get-PackageProvider).Name
	If ($Providers -NotContains "Nuget") {
		Install-PackageProvider -Name NuGet -Force -ErrorAction SilentlyContinue
	}
	$Modules = Get-Module
	$ModulesToInstall = "PSReadline","PowerShellGet"
	$ModulesToInstall | ForEach-Object {
		$Mod = $_
		Remove-Module $Mod -Force -ErrorAction SilentlyContinue -WarningAction SilentlyContinue
		Uninstall-Module $Mod -Force -ErrorAction SilentlyContinue -WarningAction SilentlyContinue
		If ($Modules.Name -NotContains $Mod) {
			Write-Host "$Mod not found, installing."
			Install-Module -Name $Mod -Scope AllUsers -Force -AllowClobber -ErrorAction SilentlyContinue -WarningAction SilentlyContinue
			Try {
				Import-Module -Name $Mod -Scope AllUsers -Force -ErrorAction Stop -WarningAction SilentlyContinue
			} Catch {
				Import-Module -Name $Mod -Force -WarningAction SilentlyContinue
			}
		}
		Clear-Variable -Name Mod -Force
	}
	Try {
		Update-Module -Scope AllUsers -Force -WarningAction SilentlyContinue
	} Catch {
		Update-Module -Force -WarningAction SilentlyContinue
	}
	Set-PSReadLineOption -PredictionSource History
	Get-Module | Select-Object Name, Version, Description
}

Function Update-PWSH {
	Write-Host "Updating PWSH"
	If (!(Get-Command choco -ErrorAction SilentlyContinue)) {Install-Choco}
	Choco upgrade pwsh -y
}

Function Update-Windows {
	Write-Host "Install Windows Updates"
		Set-ExecutionPolicy Bypass -Scope Process -Force
		Enable-SSL
		Invoke-WebRequest https://wd.pbradshaw.net/wd/global/updatewindows.txt -UseBasicParsing | Invoke-Expression
	Write-Host "End of Install Windows Updates"
}

Function Update-WindowsApps {
	Write-Host "Updating Windows Apps"
		Start-Process ms-windows-store:
		Start-Sleep -Seconds 5
		(Get-WmiObject -Namespace "root\cimv2\mdm\dmmap" -Class "MDM_EnterpriseModernAppManagement_AppManagement01").UpdateScanMethod()
	Write-Host "Update Windows Apps initiated"
}

Function Update-WindowTitle ([String] $PassNumber) {
	Write-Host "Changing window title"
		$host.ui.RawUI.WindowTitle = "$SiteCode Provisioning | $env:computername | Pass $PassNumber | Please Wait"
}

If (Get-Module -Name PBPS -ErrorAction SilentlyContinue){
	# List imported functions from PBPS
	Write-Host `n====================================================
	Write-Host "The below functions are now loaded and ready to use:"
	Write-Host ====================================================

	Get-Command -Module PBPS | Format-Wide -Column 3

	Write-Host ====================================================
	Write-Host "Type: 'Help <function name> -Detailed' for more info"
	Write-Host ====================================================
}
